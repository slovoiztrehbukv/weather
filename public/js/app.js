/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/svelte-select/ChevronIcon.svelte":
/*!*******************************************************!*\
  !*** ./node_modules/svelte-select/ChevronIcon.svelte ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/* node_modules/svelte-select/ChevronIcon.svelte generated by Svelte v3.59.1 */

function add_css(target) {
  (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-qbd276", "svg.svelte-qbd276{width:var(--chevron-icon-width, 20px);height:var(--chevron-icon-width, 20px);color:var(--chevron-icon-colour, currentColor)}");
}
function create_fragment(ctx) {
  var svg;
  var path;
  return {
    c: function c() {
      svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
      path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(path, "fill", "currentColor");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "width", "100%");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "height", "100%");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "viewBox", "0 0 20 20");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "focusable", "false");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "aria-hidden", "true");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "class", "svelte-qbd276");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, svg, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(svg, path);
    },
    p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(svg);
    }
  };
}
var ChevronIcon = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(ChevronIcon, _SvelteComponent);
  var _super = _createSuper(ChevronIcon);
  function ChevronIcon(options) {
    var _this;
    _classCallCheck(this, ChevronIcon);
    _this = _super.call(this);
    (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(_assertThisInitialized(_this), options, null, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);
    return _this;
  }
  return _createClass(ChevronIcon);
}(svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChevronIcon);

/***/ }),

/***/ "./node_modules/svelte-select/ClearIcon.svelte":
/*!*****************************************************!*\
  !*** ./node_modules/svelte-select/ClearIcon.svelte ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/* node_modules/svelte-select/ClearIcon.svelte generated by Svelte v3.59.1 */

function add_css(target) {
  (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-whdbu1", "svg.svelte-whdbu1{width:var(--clear-icon-width, 20px);height:var(--clear-icon-width, 20px);color:var(--clear-icon-color, currentColor)}");
}
function create_fragment(ctx) {
  var svg;
  var path;
  return {
    c: function c() {
      svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
      path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(path, "fill", "currentColor");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "width", "100%");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "height", "100%");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "viewBox", "-2 -2 50 50");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "focusable", "false");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "aria-hidden", "true");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "role", "presentation");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "class", "svelte-whdbu1");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, svg, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(svg, path);
    },
    p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(svg);
    }
  };
}
var ClearIcon = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(ClearIcon, _SvelteComponent);
  var _super = _createSuper(ClearIcon);
  function ClearIcon(options) {
    var _this;
    _classCallCheck(this, ClearIcon);
    _this = _super.call(this);
    (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(_assertThisInitialized(_this), options, null, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);
    return _this;
  }
  return _createClass(ClearIcon);
}(svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ClearIcon);

/***/ }),

/***/ "./node_modules/svelte-select/LoadingIcon.svelte":
/*!*******************************************************!*\
  !*** ./node_modules/svelte-select/LoadingIcon.svelte ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/* node_modules/svelte-select/LoadingIcon.svelte generated by Svelte v3.59.1 */

function add_css(target) {
  (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-1p3nqvd", ".loading.svelte-1p3nqvd{width:var(--spinner-width, 20px);height:var(--spinner-height, 20px);color:var(--spinner-color, var(--icons-color));animation:svelte-1p3nqvd-rotate 0.75s linear infinite;transform-origin:center center;transform:none}.circle_path.svelte-1p3nqvd{stroke-dasharray:90;stroke-linecap:round}@keyframes svelte-1p3nqvd-rotate{100%{transform:rotate(360deg)}}");
}
function create_fragment(ctx) {
  var svg;
  var circle;
  return {
    c: function c() {
      svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
      circle = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("circle");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(circle, "class", "circle_path svelte-1p3nqvd");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(circle, "cx", "50");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(circle, "cy", "50");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(circle, "r", "20");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(circle, "fill", "none");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(circle, "stroke", "currentColor");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(circle, "stroke-width", "5");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(circle, "stroke-miterlimit", "10");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "class", "loading svelte-1p3nqvd");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "viewBox", "25 25 50 50");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, svg, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(svg, circle);
    },
    p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(svg);
    }
  };
}
var LoadingIcon = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(LoadingIcon, _SvelteComponent);
  var _super = _createSuper(LoadingIcon);
  function LoadingIcon(options) {
    var _this;
    _classCallCheck(this, LoadingIcon);
    _this = _super.call(this);
    (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(_assertThisInitialized(_this), options, null, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);
    return _this;
  }
  return _createClass(LoadingIcon);
}(svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoadingIcon);

/***/ }),

/***/ "./node_modules/svelte-select/Select.svelte":
/*!**************************************************!*\
  !*** ./node_modules/svelte-select/Select.svelte ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs");
/* harmony import */ var svelte_floating_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte-floating-ui */ "./node_modules/svelte-floating-ui/index.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter */ "./node_modules/svelte-select/filter.js");
/* harmony import */ var _get_items__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-items */ "./node_modules/svelte-select/get-items.js");
/* harmony import */ var _ChevronIcon_svelte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ChevronIcon.svelte */ "./node_modules/svelte-select/ChevronIcon.svelte");
/* harmony import */ var _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ClearIcon.svelte */ "./node_modules/svelte-select/ClearIcon.svelte");
/* harmony import */ var _LoadingIcon_svelte__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./LoadingIcon.svelte */ "./node_modules/svelte-select/LoadingIcon.svelte");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/* node_modules/svelte-select/Select.svelte generated by Svelte v3.59.1 */









function add_css(target) {
  (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-apvs86", ".svelte-select.svelte-apvs86.svelte-apvs86.svelte-apvs86{--borderRadius:var(--border-radius);--clearSelectColor:var(--clear-select-color);--clearSelectWidth:var(--clear-select-width);--disabledBackground:var(--disabled-background);--disabledBorderColor:var(--disabled-border-color);--disabledColor:var(--disabled-color);--disabledPlaceholderColor:var(--disabled-placeholder-color);--disabledPlaceholderOpacity:var(--disabled-placeholder-opacity);--errorBackground:var(--error-background);--errorBorder:var(--error-border);--groupItemPaddingLeft:var(--group-item-padding-left);--groupTitleColor:var(--group-title-color);--groupTitleFontSize:var(--group-title-font-size);--groupTitleFontWeight:var(--group-title-font-weight);--groupTitlePadding:var(--group-title-padding);--groupTitleTextTransform:var(--group-title-text-transform);--indicatorColor:var(--chevron-color);--indicatorHeight:var(--chevron-height);--indicatorWidth:var(--chevron-width);--inputColor:var(--input-color);--inputLeft:var(--input-left);--inputLetterSpacing:var(--input-letter-spacing);--inputMargin:var(--input-margin);--inputPadding:var(--input-padding);--itemActiveBackground:var(--item-active-background);--itemColor:var(--item-color);--itemFirstBorderRadius:var(--item-first-border-radius);--itemHoverBG:var(--item-hover-bg);--itemHoverColor:var(--item-hover-color);--itemIsActiveBG:var(--item-is-active-bg);--itemIsActiveColor:var(--item-is-active-color);--itemIsNotSelectableColor:var(--item-is-not-selectable-color);--itemPadding:var(--item-padding);--listBackground:var(--list-background);--listBorder:var(--list-border);--listBorderRadius:var(--list-border-radius);--listEmptyColor:var(--list-empty-color);--listEmptyPadding:var(--list-empty-padding);--listEmptyTextAlign:var(--list-empty-text-align);--listMaxHeight:var(--list-max-height);--listPosition:var(--list-position);--listShadow:var(--list-shadow);--listZIndex:var(--list-z-index);--multiItemBG:var(--multi-item-bg);--multiItemBorderRadius:var(--multi-item-border-radius);--multiItemDisabledHoverBg:var(--multi-item-disabled-hover-bg);--multiItemDisabledHoverColor:var(--multi-item-disabled-hover-color);--multiItemHeight:var(--multi-item-height);--multiItemMargin:var(--multi-item-margin);--multiItemPadding:var(--multi-item-padding);--multiSelectInputMargin:var(--multi-select-input-margin);--multiSelectInputPadding:var(--multi-select-input-padding);--multiSelectPadding:var(--multi-select-padding);--placeholderColor:var(--placeholder-color);--placeholderOpacity:var(--placeholder-opacity);--selectedItemPadding:var(--selected-item-padding);--spinnerColor:var(--spinner-color);--spinnerHeight:var(--spinner-height);--spinnerWidth:var(--spinner-width);--internal-padding:0 0 0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--border-radius, 6px);min-height:var(--height, 42px);position:relative;display:flex;align-items:stretch;padding:var(--padding, var(--internal-padding));background:var(--background, #fff);margin:var(--margin, 0);width:var(--width, 100%);font-size:var(--font-size, 16px);max-height:var(--max-height)}.svelte-apvs86.svelte-apvs86.svelte-apvs86{box-sizing:var(--box-sizing, border-box)}.svelte-select.svelte-apvs86.svelte-apvs86.svelte-apvs86:hover{border:var(--border-hover, 1px solid #b2b8bf)}.value-container.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;flex:1 1 0%;flex-wrap:wrap;align-items:center;gap:5px 10px;padding:var(--value-container-padding, 5px 0);position:relative;overflow:var(--value-container-overflow, hidden);align-self:stretch}.prepend.svelte-apvs86.svelte-apvs86.svelte-apvs86,.indicators.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;flex-shrink:0;align-items:center}.indicators.svelte-apvs86.svelte-apvs86.svelte-apvs86{position:var(--indicators-position);top:var(--indicators-top);right:var(--indicators-right);bottom:var(--indicators-bottom)}input.svelte-apvs86.svelte-apvs86.svelte-apvs86{position:absolute;cursor:default;border:none;color:var(--input-color, var(--item-color));padding:var(--input-padding, 0);letter-spacing:var(--input-letter-spacing, inherit);margin:var(--input-margin, 0);min-width:10px;top:0;right:0;bottom:0;left:0;background:transparent;font-size:var(--font-size, 16px)}.svelte-apvs86:not(.multi)>.value-container.svelte-apvs86>input.svelte-apvs86{width:100%;height:100%}input.svelte-apvs86.svelte-apvs86.svelte-apvs86::placeholder{color:var(--placeholder-color, #78848f);opacity:var(--placeholder-opacity, 1)}input.svelte-apvs86.svelte-apvs86.svelte-apvs86:focus{outline:none}.svelte-select.focused.svelte-apvs86.svelte-apvs86.svelte-apvs86{border:var(--border-focused, 1px solid #006fe8);border-radius:var(--border-radius-focused, var(--border-radius, 6px))}.disabled.svelte-apvs86.svelte-apvs86.svelte-apvs86{background:var(--disabled-background, #ebedef);border-color:var(--disabled-border-color, #ebedef);color:var(--disabled-color, #c1c6cc)}.disabled.svelte-apvs86 input.svelte-apvs86.svelte-apvs86::placeholder{color:var(--disabled-placeholder-color, #c1c6cc);opacity:var(--disabled-placeholder-opacity, 1)}.selected-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{position:relative;overflow:var(--selected-item-overflow, hidden);padding:var(--selected-item-padding, 0 20px 0 0);text-overflow:ellipsis;white-space:nowrap;color:var(--selected-item-color, inherit);font-size:var(--font-size, 16px)}.multi.svelte-apvs86 .selected-item.svelte-apvs86.svelte-apvs86{position:absolute;line-height:var(--height, 42px);height:var(--height, 42px)}.selected-item.svelte-apvs86.svelte-apvs86.svelte-apvs86:focus{outline:none}.hide-selected-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{opacity:0}.icon.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;align-items:center;justify-content:center}.clear-select.svelte-apvs86.svelte-apvs86.svelte-apvs86{all:unset;display:flex;align-items:center;justify-content:center;width:var(--clear-select-width, 40px);height:var(--clear-select-height, 100%);color:var(--clear-select-color, var(--icons-color));margin:var(--clear-select-margin, 0);pointer-events:all;flex-shrink:0}.clear-select.svelte-apvs86.svelte-apvs86.svelte-apvs86:focus{outline:var(--clear-select-focus-outline, 1px solid #006fe8)}.loading.svelte-apvs86.svelte-apvs86.svelte-apvs86{width:var(--loading-width, 40px);height:var(--loading-height);color:var(--loading-color, var(--icons-color));margin:var(--loading--margin, 0);flex-shrink:0}.chevron.svelte-apvs86.svelte-apvs86.svelte-apvs86{width:var(--chevron-width, 40px);height:var(--chevron-height, 40px);background:var(--chevron-background, transparent);pointer-events:var(--chevron-pointer-events, none);color:var(--chevron-color, var(--icons-color));border:var(--chevron-border, 0 0 0 1px solid #d8dbdf);flex-shrink:0}.multi.svelte-apvs86.svelte-apvs86.svelte-apvs86{padding:var(--multi-select-padding, var(--internal-padding))}.multi.svelte-apvs86 input.svelte-apvs86.svelte-apvs86{padding:var(--multi-select-input-padding, 0);position:relative;margin:var(--multi-select-input-margin, 5px 0);flex:1 1 40px}.svelte-select.error.svelte-apvs86.svelte-apvs86.svelte-apvs86{border:var(--error-border, 1px solid #ff2d55);background:var(--error-background, #fff)}.a11y-text.svelte-apvs86.svelte-apvs86.svelte-apvs86{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}.multi-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{background:var(--multi-item-bg, #ebedef);margin:var(--multi-item-margin, 0);outline:var(--multi-item-outline, 1px solid #ddd);border-radius:var(--multi-item-border-radius, 4px);height:var(--multi-item-height, 25px);line-height:var(--multi-item-height, 25px);display:flex;cursor:default;padding:var(--multi-item-padding, 0 5px);overflow:hidden;gap:var(--multi-item-gap, 4px);outline-offset:-1px;max-width:var(--multi-max-width, none);color:var(--multi-item-color, var(--item-color))}.multi-item.disabled.svelte-apvs86.svelte-apvs86.svelte-apvs86:hover{background:var(--multi-item-disabled-hover-bg, #ebedef);color:var(--multi-item-disabled-hover-color, #c1c6cc)}.multi-item-text.svelte-apvs86.svelte-apvs86.svelte-apvs86{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multi-item-clear.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;align-items:center;justify-content:center;--clear-icon-color:var(--multi-item-clear-icon-color, #000)}.multi-item.active.svelte-apvs86.svelte-apvs86.svelte-apvs86{outline:var(--multi-item-active-outline, 1px solid #006fe8)}.svelte-select-list.svelte-apvs86.svelte-apvs86.svelte-apvs86{box-shadow:var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--list-border-radius, 4px);max-height:var(--list-max-height, 252px);overflow-y:auto;background:var(--list-background, #fff);position:var(--list-position, absolute);z-index:var(--list-z-index, 2);border:var(--list-border)}.prefloat.svelte-apvs86.svelte-apvs86.svelte-apvs86{opacity:0;pointer-events:none}.list-group-title.svelte-apvs86.svelte-apvs86.svelte-apvs86{color:var(--group-title-color, #8f8f8f);cursor:default;font-size:var(--group-title-font-size, 16px);font-weight:var(--group-title-font-weight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--group-title-padding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--group-title-text-transform, uppercase)}.empty.svelte-apvs86.svelte-apvs86.svelte-apvs86{text-align:var(--list-empty-text-align, center);padding:var(--list-empty-padding, 20px 0);color:var(--list-empty-color, #78848f)}.item.svelte-apvs86.svelte-apvs86.svelte-apvs86{cursor:default;height:var(--item-height, var(--height, 42px));line-height:var(--item-line-height, var(--height, 42px));padding:var(--item-padding, 0 20px);color:var(--item-color, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap;transition:var(--item-transition, all 0.2s);align-items:center;width:100%}.item.group-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{padding-left:var(--group-item-padding-left, 40px)}.item.svelte-apvs86.svelte-apvs86.svelte-apvs86:active{background:var(--item-active-background, #b9daff)}.item.active.svelte-apvs86.svelte-apvs86.svelte-apvs86{background:var(--item-is-active-bg, #007aff);color:var(--item-is-active-color, #fff)}.item.first.svelte-apvs86.svelte-apvs86.svelte-apvs86{border-radius:var(--item-first-border-radius, 4px 4px 0 0)}.item.hover.svelte-apvs86.svelte-apvs86.svelte-apvs86:not(.active){background:var(--item-hover-bg, #e7f2ff);color:var(--item-hover-color, inherit)}.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86,.item.hover.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86,.item.active.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86,.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86:active{color:var(--item-is-not-selectable-color, #999);background:transparent}.required.svelte-apvs86.svelte-apvs86.svelte-apvs86{opacity:0;z-index:-1;position:absolute;top:0;left:0;bottom:0;right:0}");
}
var get_required_slot_changes = function get_required_slot_changes(dirty) {
  return {
    value: dirty[0] & /*value*/8
  };
};
var get_required_slot_context = function get_required_slot_context(ctx) {
  return {
    value: /*value*/ctx[3]
  };
};
var get_input_hidden_slot_changes = function get_input_hidden_slot_changes(dirty) {
  return {
    value: dirty[0] & /*value*/8
  };
};
var get_input_hidden_slot_context = function get_input_hidden_slot_context(ctx) {
  return {
    value: /*value*/ctx[3]
  };
};
var get_chevron_icon_slot_changes = function get_chevron_icon_slot_changes(dirty) {
  return {
    listOpen: dirty[0] & /*listOpen*/64
  };
};
var get_chevron_icon_slot_context = function get_chevron_icon_slot_context(ctx) {
  return {
    listOpen: /*listOpen*/ctx[6]
  };
};
var get_clear_icon_slot_changes = function get_clear_icon_slot_changes(dirty) {
  return {};
};
var get_clear_icon_slot_context = function get_clear_icon_slot_context(ctx) {
  return {};
};
var get_loading_icon_slot_changes = function get_loading_icon_slot_changes(dirty) {
  return {};
};
var get_loading_icon_slot_context = function get_loading_icon_slot_context(ctx) {
  return {};
};
var get_selection_slot_changes_1 = function get_selection_slot_changes_1(dirty) {
  return {
    selection: dirty[0] & /*value*/8
  };
};
var get_selection_slot_context_1 = function get_selection_slot_context_1(ctx) {
  return {
    selection: /*value*/ctx[3]
  };
};
function get_each_context(ctx, list, i) {
  var child_ctx = ctx.slice();
  child_ctx[125] = list[i];
  child_ctx[127] = i;
  return child_ctx;
}
var get_multi_clear_icon_slot_changes = function get_multi_clear_icon_slot_changes(dirty) {
  return {};
};
var get_multi_clear_icon_slot_context = function get_multi_clear_icon_slot_context(ctx) {
  return {};
};
var get_selection_slot_changes = function get_selection_slot_changes(dirty) {
  return {
    selection: dirty[0] & /*value*/8
  };
};
var get_selection_slot_context = function get_selection_slot_context(ctx) {
  return {
    selection: /*item*/ctx[125],
    index: /*i*/ctx[127]
  };
};
var get_prepend_slot_changes = function get_prepend_slot_changes(dirty) {
  return {};
};
var get_prepend_slot_context = function get_prepend_slot_context(ctx) {
  return {};
};
var get_list_append_slot_changes = function get_list_append_slot_changes(dirty) {
  return {};
};
var get_list_append_slot_context = function get_list_append_slot_context(ctx) {
  return {};
};
var get_empty_slot_changes = function get_empty_slot_changes(dirty) {
  return {};
};
var get_empty_slot_context = function get_empty_slot_context(ctx) {
  return {};
};
function get_each_context_1(ctx, list, i) {
  var child_ctx = ctx.slice();
  child_ctx[125] = list[i];
  child_ctx[127] = i;
  return child_ctx;
}
var get_item_slot_changes = function get_item_slot_changes(dirty) {
  return {
    item: dirty[0] & /*filteredItems*/16777216
  };
};
var get_item_slot_context = function get_item_slot_context(ctx) {
  return {
    item: /*item*/ctx[125],
    index: /*i*/ctx[127]
  };
};
var get_list_slot_changes = function get_list_slot_changes(dirty) {
  return {
    filteredItems: dirty[0] & /*filteredItems*/16777216
  };
};
var get_list_slot_context = function get_list_slot_context(ctx) {
  return {
    filteredItems: /*filteredItems*/ctx[24]
  };
};
var get_list_prepend_slot_changes = function get_list_prepend_slot_changes(dirty) {
  return {};
};
var get_list_prepend_slot_context = function get_list_prepend_slot_context(ctx) {
  return {};
};

// (682:4) {#if listOpen}
function create_if_block_8(ctx) {
  var div;
  var t0;
  var current_block_type_index;
  var if_block1;
  var t1;
  var floatingContent_action;
  var current;
  var mounted;
  var dispose;
  var if_block0 = /*$$slots*/ctx[50]['list-prepend'] && create_if_block_13(ctx);
  var if_block_creators = [create_if_block_10, create_if_block_11, create_if_block_12];
  var if_blocks = [];
  function select_block_type(ctx, dirty) {
    if ( /*$$slots*/ctx[50].list) return 0;
    if ( /*filteredItems*/ctx[24].length > 0) return 1;
    if (! /*hideEmptyState*/ctx[19]) return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1]))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  var if_block2 = /*$$slots*/ctx[50]['list-append'] && create_if_block_9(ctx);
  return {
    c: function c() {
      div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (if_block0) if_block0.c();
      t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      if (if_block1) if_block1.c();
      t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      if (if_block2) if_block2.c();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "svelte-select-list svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "prefloat", /*prefloat*/ctx[28]);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t1);
      if (if_block2) if_block2.m(div, null);
      /*div_binding*/
      ctx[90](div);
      current = true;
      if (!mounted) {
        dispose = [(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.action_destroyer)(floatingContent_action = /*floatingContent*/ctx[49].call(null, div)), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div, "scroll", /*handleListScroll*/ctx[41]), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div, "pointerup", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)( /*pointerup_handler*/ctx[85])))];
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      if ( /*$$slots*/ctx[50]['list-prepend']) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[1] & /*$$slots*/524288) {
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx);
          if_block0.c();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0, 1, 1, function () {
          if_block0 = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
      var previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block1) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_blocks[previous_block_index], 1, 1, function () {
            if_blocks[previous_block_index] = null;
          });
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block1.c();
          } else {
            if_block1.p(ctx, dirty);
          }
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);
          if_block1.m(div, t1);
        } else {
          if_block1 = null;
        }
      }
      if ( /*$$slots*/ctx[50]['list-append']) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty[1] & /*$$slots*/524288) {
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_9(ctx);
          if_block2.c();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2, 1, 1, function () {
          if_block2 = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
      if (!current || dirty[0] & /*prefloat*/268435456) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "prefloat", /*prefloat*/ctx[28]);
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
      if (if_block0) if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block2) if_block2.d();
      /*div_binding*/
      ctx[90](null);
      mounted = false;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
    }
  };
}

// (690:12) {#if $$slots['list-prepend']}
function create_if_block_13(ctx) {
  var current;
  var list_prepend_slot_template = /*#slots*/ctx[82]["list-prepend"];
  var list_prepend_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(list_prepend_slot_template, ctx, /*$$scope*/ctx[81], get_list_prepend_slot_context);
  return {
    c: function c() {
      if (list_prepend_slot) list_prepend_slot.c();
    },
    m: function m(target, anchor) {
      if (list_prepend_slot) {
        list_prepend_slot.m(target, anchor);
      }
      current = true;
    },
    p: function p(ctx, dirty) {
      if (list_prepend_slot) {
        if (list_prepend_slot.p && (!current || dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(list_prepend_slot, list_prepend_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(list_prepend_slot_template, /*$$scope*/ctx[81], dirty, get_list_prepend_slot_changes), get_list_prepend_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(list_prepend_slot, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(list_prepend_slot, local);
      current = false;
    },
    d: function d(detaching) {
      if (list_prepend_slot) list_prepend_slot.d(detaching);
    }
  };
}

// (717:38) 
function create_if_block_12(ctx) {
  var current;
  var empty_slot_template = /*#slots*/ctx[82].empty;
  var empty_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(empty_slot_template, ctx, /*$$scope*/ctx[81], get_empty_slot_context);
  var empty_slot_or_fallback = empty_slot || fallback_block_9(ctx);
  return {
    c: function c() {
      if (empty_slot_or_fallback) empty_slot_or_fallback.c();
    },
    m: function m(target, anchor) {
      if (empty_slot_or_fallback) {
        empty_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function p(ctx, dirty) {
      if (empty_slot) {
        if (empty_slot.p && (!current || dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(empty_slot, empty_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(empty_slot_template, /*$$scope*/ctx[81], dirty, get_empty_slot_changes), get_empty_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(empty_slot_or_fallback, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(empty_slot_or_fallback, local);
      current = false;
    },
    d: function d(detaching) {
      if (empty_slot_or_fallback) empty_slot_or_fallback.d(detaching);
    }
  };
}

// (692:47) 
function create_if_block_11(ctx) {
  var each_1_anchor;
  var current;
  var each_value_1 = /*filteredItems*/ctx[24];
  var each_blocks = [];
  for (var i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  var out = function out(i) {
    return (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i], 1, 1, function () {
      each_blocks[i] = null;
    });
  };
  return {
    c: function c() {
      for (var _i = 0; _i < each_blocks.length; _i += 1) {
        each_blocks[_i].c();
      }
      each_1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
    },
    m: function m(target, anchor) {
      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
        if (each_blocks[_i2]) {
          each_blocks[_i2].m(target, anchor);
        }
      }
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, each_1_anchor, anchor);
      current = true;
    },
    p: function p(ctx, dirty) {
      if (dirty[0] & /*filteredItems, value, itemId, listDom, scrollToHoverItem, hoverItemIndex, label*/1627402376 | dirty[1] & /*handleHover, handleItemClick, isItemActive*/28672 | dirty[2] & /*$$scope*/524288) {
        each_value_1 = /*filteredItems*/ctx[24];
        var _i3;
        for (_i3 = 0; _i3 < each_value_1.length; _i3 += 1) {
          var child_ctx = get_each_context_1(ctx, each_value_1, _i3);
          if (each_blocks[_i3]) {
            each_blocks[_i3].p(child_ctx, dirty);
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[_i3], 1);
          } else {
            each_blocks[_i3] = create_each_block_1(child_ctx);
            each_blocks[_i3].c();
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[_i3], 1);
            each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        for (_i3 = each_value_1.length; _i3 < each_blocks.length; _i3 += 1) {
          out(_i3);
        }
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
    },
    i: function i(local) {
      if (current) return;
      for (var _i4 = 0; _i4 < each_value_1.length; _i4 += 1) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[_i4]);
      }
      current = true;
    },
    o: function o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[_i5]);
      }
      current = false;
    },
    d: function d(detaching) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(each_1_anchor);
    }
  };
}

// (691:12) {#if $$slots.list}
function create_if_block_10(ctx) {
  var current;
  var list_slot_template = /*#slots*/ctx[82].list;
  var list_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(list_slot_template, ctx, /*$$scope*/ctx[81], get_list_slot_context);
  return {
    c: function c() {
      if (list_slot) list_slot.c();
    },
    m: function m(target, anchor) {
      if (list_slot) {
        list_slot.m(target, anchor);
      }
      current = true;
    },
    p: function p(ctx, dirty) {
      if (list_slot) {
        if (list_slot.p && (!current || dirty[0] & /*filteredItems*/16777216 | dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(list_slot, list_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(list_slot_template, /*$$scope*/ctx[81], dirty, get_list_slot_changes), get_list_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(list_slot, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(list_slot, local);
      current = false;
    },
    d: function d(detaching) {
      if (list_slot) list_slot.d(detaching);
    }
  };
}

// (718:35)                      
function fallback_block_9(ctx) {
  var div;
  return {
    c: function c() {
      div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      div.textContent = "No options";
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "empty svelte-apvs86");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
    },
    p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
    }
  };
}

// (711:63)                                  
function fallback_block_8(ctx) {
  var _ctx$;
  var t_value = /*item*/((_ctx$ = ctx[125]) === null || _ctx$ === void 0 ? void 0 : _ctx$[/*label*/ctx[12]]) + "";
  var t;
  return {
    c: function c() {
      t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t, anchor);
    },
    p: function p(ctx, dirty) {
      var _ctx$2;
      if (dirty[0] & /*filteredItems, label*/16781312 && t_value !== (t_value = /*item*/((_ctx$2 = ctx[125]) === null || _ctx$2 === void 0 ? void 0 : _ctx$2[/*label*/ctx[12]]) + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t, t_value);
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t);
    }
  };
}

// (693:16) {#each filteredItems as item, i}
function create_each_block_1(ctx) {
  var div1;
  var div0;
  var activeScroll_action;
  var hoverScroll_action;
  var t;
  var current;
  var mounted;
  var dispose;
  var item_slot_template = /*#slots*/ctx[82].item;
  var item_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(item_slot_template, ctx, /*$$scope*/ctx[81], get_item_slot_context);
  var item_slot_or_fallback = item_slot || fallback_block_8(ctx);
  function mouseover_handler() {
    return (/*mouseover_handler*/ctx[87]( /*i*/ctx[127])
    );
  }
  function focus_handler() {
    return (/*focus_handler*/ctx[88]( /*i*/ctx[127])
    );
  }
  function click_handler() {
    return (/*click_handler*/ctx[89]( /*item*/ctx[125], /*i*/ctx[127])
    );
  }
  return {
    c: function c() {
      var _ctx$3;
      div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (item_slot_or_fallback) item_slot_or_fallback.c();
      t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div0, "class", "item svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "list-group-title", /*item*/ctx[125].groupHeader);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "active", /*isItemActive*/ctx[45]( /*item*/ctx[125], /*value*/ctx[3], /*itemId*/ctx[13]));
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "first", isItemFirst( /*i*/ctx[127]));
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "hover", /*hoverItemIndex*/ctx[7] === /*i*/ctx[127]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "group-item", /*item*/ctx[125].groupItem);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "not-selectable", /*item*/((_ctx$3 = ctx[125]) === null || _ctx$3 === void 0 ? void 0 : _ctx$3.selectable) === false);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div1, "class", "list-item svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div1, "tabindex", "-1");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div1, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div1, div0);
      if (item_slot_or_fallback) {
        item_slot_or_fallback.m(div0, null);
      }
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div1, t);
      current = true;
      if (!mounted) {
        dispose = [(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.action_destroyer)(activeScroll_action = /*activeScroll*/ctx[46].call(null, div0, {
          scroll: /*isItemActive*/ctx[45]( /*item*/ctx[125], /*value*/ctx[3], /*itemId*/ctx[13]),
          listDom: /*listDom*/ctx[30]
        })), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.action_destroyer)(hoverScroll_action = /*hoverScroll*/ctx[47].call(null, div0, {
          scroll: /*scrollToHoverItem*/ctx[29] === /*i*/ctx[127],
          listDom: /*listDom*/ctx[30]
        })), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div1, "mouseover", mouseover_handler), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div1, "focus", focus_handler), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div1, "click", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)(click_handler)), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div1, "keydown", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)( /*keydown_handler*/ctx[86])))];
        mounted = true;
      }
    },
    p: function p(new_ctx, dirty) {
      ctx = new_ctx;
      if (item_slot) {
        if (item_slot.p && (!current || dirty[0] & /*filteredItems*/16777216 | dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(item_slot, item_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(item_slot_template, /*$$scope*/ctx[81], dirty, get_item_slot_changes), get_item_slot_context);
        }
      } else {
        if (item_slot_or_fallback && item_slot_or_fallback.p && (!current || dirty[0] & /*filteredItems, label*/16781312)) {
          item_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (activeScroll_action && (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.is_function)(activeScroll_action.update) && dirty[0] & /*filteredItems, value, itemId, listDom*/1090527240) activeScroll_action.update.call(null, {
        scroll: /*isItemActive*/ctx[45]( /*item*/ctx[125], /*value*/ctx[3], /*itemId*/ctx[13]),
        listDom: /*listDom*/ctx[30]
      });
      if (hoverScroll_action && (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.is_function)(hoverScroll_action.update) && dirty[0] & /*scrollToHoverItem, listDom*/1610612736) hoverScroll_action.update.call(null, {
        scroll: /*scrollToHoverItem*/ctx[29] === /*i*/ctx[127],
        listDom: /*listDom*/ctx[30]
      });
      if (!current || dirty[0] & /*filteredItems*/16777216) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "list-group-title", /*item*/ctx[125].groupHeader);
      }
      if (!current || dirty[0] & /*filteredItems, value, itemId*/16785416 | dirty[1] & /*isItemActive*/16384) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "active", /*isItemActive*/ctx[45]( /*item*/ctx[125], /*value*/ctx[3], /*itemId*/ctx[13]));
      }
      if (!current || dirty[0] & /*hoverItemIndex*/128) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "hover", /*hoverItemIndex*/ctx[7] === /*i*/ctx[127]);
      }
      if (!current || dirty[0] & /*filteredItems*/16777216) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "group-item", /*item*/ctx[125].groupItem);
      }
      if (!current || dirty[0] & /*filteredItems*/16777216) {
        var _ctx$4;
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "not-selectable", /*item*/((_ctx$4 = ctx[125]) === null || _ctx$4 === void 0 ? void 0 : _ctx$4.selectable) === false);
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(item_slot_or_fallback, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(item_slot_or_fallback, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div1);
      if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
      mounted = false;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
    }
  };
}

// (722:12) {#if $$slots['list-append']}
function create_if_block_9(ctx) {
  var current;
  var list_append_slot_template = /*#slots*/ctx[82]["list-append"];
  var list_append_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(list_append_slot_template, ctx, /*$$scope*/ctx[81], get_list_append_slot_context);
  return {
    c: function c() {
      if (list_append_slot) list_append_slot.c();
    },
    m: function m(target, anchor) {
      if (list_append_slot) {
        list_append_slot.m(target, anchor);
      }
      current = true;
    },
    p: function p(ctx, dirty) {
      if (list_append_slot) {
        if (list_append_slot.p && (!current || dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(list_append_slot, list_append_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(list_append_slot_template, /*$$scope*/ctx[81], dirty, get_list_append_slot_changes), get_list_append_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(list_append_slot, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(list_append_slot, local);
      current = false;
    },
    d: function d(detaching) {
      if (list_append_slot) list_append_slot.d(detaching);
    }
  };
}

// (727:8) {#if focused}
function create_if_block_7(ctx) {
  var span0;
  var t0;
  var t1;
  var span1;
  var t2;
  return {
    c: function c() {
      span0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
      t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)( /*ariaSelection*/ctx[32]);
      t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      span1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
      t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)( /*ariaContext*/ctx[31]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span0, "id", "aria-selection");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span0, "class", "svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span1, "id", "aria-context");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span1, "class", "svelte-apvs86");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, span0, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(span0, t0);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t1, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, span1, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(span1, t2);
    },
    p: function p(ctx, dirty) {
      if (dirty[1] & /*ariaSelection*/2) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t0, /*ariaSelection*/ctx[32]);
      if (dirty[1] & /*ariaContext*/1) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t2, /*ariaContext*/ctx[31]);
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(span0);
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t1);
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(span1);
    }
  };
}

// (740:8) {#if hasValue}
function create_if_block_4(ctx) {
  var current_block_type_index;
  var if_block;
  var if_block_anchor;
  var current;
  var if_block_creators = [create_if_block_5, create_else_block];
  var if_blocks = [];
  function select_block_type_1(ctx, dirty) {
    if ( /*multiple*/ctx[9]) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c: function c() {
      if_block.c();
      if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
    },
    m: function m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, if_block_anchor, anchor);
      current = true;
    },
    p: function p(ctx, dirty) {
      var previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_blocks[previous_block_index], 1, 1, function () {
          if_blocks[previous_block_index] = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
      current = false;
    },
    d: function d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(if_block_anchor);
    }
  };
}

// (766:12) {:else}
function create_else_block(ctx) {
  var div;
  var current;
  var selection_slot_template = /*#slots*/ctx[82].selection;
  var selection_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(selection_slot_template, ctx, /*$$scope*/ctx[81], get_selection_slot_context_1);
  var selection_slot_or_fallback = selection_slot || fallback_block_7(ctx);
  return {
    c: function c() {
      div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (selection_slot_or_fallback) selection_slot_or_fallback.c();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "selected-item svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "hide-selected-item", /*hideSelectedItem*/ctx[35]);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
      if (selection_slot_or_fallback) {
        selection_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function p(ctx, dirty) {
      if (selection_slot) {
        if (selection_slot.p && (!current || dirty[0] & /*value*/8 | dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(selection_slot, selection_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(selection_slot_template, /*$$scope*/ctx[81], dirty, get_selection_slot_changes_1), get_selection_slot_context_1);
        }
      } else {
        if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/4104)) {
          selection_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[1] & /*hideSelectedItem*/16) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "hide-selected-item", /*hideSelectedItem*/ctx[35]);
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(selection_slot_or_fallback, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(selection_slot_or_fallback, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
      if (selection_slot_or_fallback) selection_slot_or_fallback.d(detaching);
    }
  };
}

// (741:12) {#if multiple}
function create_if_block_5(ctx) {
  var each_1_anchor;
  var current;
  var each_value = /*value*/ctx[3];
  var each_blocks = [];
  for (var i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  var out = function out(i) {
    return (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i], 1, 1, function () {
      each_blocks[i] = null;
    });
  };
  return {
    c: function c() {
      for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {
        each_blocks[_i6].c();
      }
      each_1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
    },
    m: function m(target, anchor) {
      for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {
        if (each_blocks[_i7]) {
          each_blocks[_i7].m(target, anchor);
        }
      }
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, each_1_anchor, anchor);
      current = true;
    },
    p: function p(ctx, dirty) {
      if (dirty[0] & /*activeValue, disabled, multiFullItemClearable, value, label*/67116040 | dirty[1] & /*handleMultiItemClear*/32 | dirty[2] & /*$$scope*/524288) {
        each_value = /*value*/ctx[3];
        var _i8;
        for (_i8 = 0; _i8 < each_value.length; _i8 += 1) {
          var child_ctx = get_each_context(ctx, each_value, _i8);
          if (each_blocks[_i8]) {
            each_blocks[_i8].p(child_ctx, dirty);
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[_i8], 1);
          } else {
            each_blocks[_i8] = create_each_block(child_ctx);
            each_blocks[_i8].c();
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[_i8], 1);
            each_blocks[_i8].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        for (_i8 = each_value.length; _i8 < each_blocks.length; _i8 += 1) {
          out(_i8);
        }
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
    },
    i: function i(local) {
      if (current) return;
      for (var _i9 = 0; _i9 < each_value.length; _i9 += 1) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[_i9]);
      }
      current = true;
    },
    o: function o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (var _i10 = 0; _i10 < each_blocks.length; _i10 += 1) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[_i10]);
      }
      current = false;
    },
    d: function d(detaching) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(each_1_anchor);
    }
  };
}

// (768:61)                          
function fallback_block_7(ctx) {
  var t_value = /*value*/ctx[3][/*label*/ctx[12]] + "";
  var t;
  return {
    c: function c() {
      t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t, anchor);
    },
    p: function p(ctx, dirty) {
      if (dirty[0] & /*value, label*/4104 && t_value !== (t_value = /*value*/ctx[3][/*label*/ctx[12]] + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t, t_value);
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t);
    }
  };
}

// (750:78)                                  
function fallback_block_6(ctx) {
  var t_value = /*item*/ctx[125][/*label*/ctx[12]] + "";
  var t;
  return {
    c: function c() {
      t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t, anchor);
    },
    p: function p(ctx, dirty) {
      if (dirty[0] & /*value, label*/4104 && t_value !== (t_value = /*item*/ctx[125][/*label*/ctx[12]] + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t, t_value);
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t);
    }
  };
}

// (755:24) {#if !disabled && !multiFullItemClearable && ClearIcon}
function create_if_block_6(ctx) {
  var div;
  var current;
  var mounted;
  var dispose;
  var multi_clear_icon_slot_template = /*#slots*/ctx[82]["multi-clear-icon"];
  var multi_clear_icon_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(multi_clear_icon_slot_template, ctx, /*$$scope*/ctx[81], get_multi_clear_icon_slot_context);
  var multi_clear_icon_slot_or_fallback = multi_clear_icon_slot || fallback_block_5(ctx);
  function pointerup_handler_1() {
    return (/*pointerup_handler_1*/ctx[91]( /*i*/ctx[127])
    );
  }
  return {
    c: function c() {
      div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (multi_clear_icon_slot_or_fallback) multi_clear_icon_slot_or_fallback.c();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "multi-item-clear svelte-apvs86");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
      if (multi_clear_icon_slot_or_fallback) {
        multi_clear_icon_slot_or_fallback.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div, "pointerup", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(pointerup_handler_1)));
        mounted = true;
      }
    },
    p: function p(new_ctx, dirty) {
      ctx = new_ctx;
      if (multi_clear_icon_slot) {
        if (multi_clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(multi_clear_icon_slot, multi_clear_icon_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(multi_clear_icon_slot_template, /*$$scope*/ctx[81], dirty, get_multi_clear_icon_slot_changes), get_multi_clear_icon_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(multi_clear_icon_slot_or_fallback, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(multi_clear_icon_slot_or_fallback, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
      if (multi_clear_icon_slot_or_fallback) multi_clear_icon_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
}

// (759:62)                                      
function fallback_block_5(ctx) {
  var clearicon;
  var current;
  clearicon = new _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__["default"]({});
  return {
    c: function c() {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(clearicon.$$.fragment);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(clearicon, target, anchor);
      current = true;
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(clearicon.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(clearicon.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(clearicon, detaching);
    }
  };
}

// (742:16) {#each value as item, i}
function create_each_block(ctx) {
  var div;
  var span;
  var t0;
  var t1;
  var current;
  var mounted;
  var dispose;
  var selection_slot_template = /*#slots*/ctx[82].selection;
  var selection_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(selection_slot_template, ctx, /*$$scope*/ctx[81], get_selection_slot_context);
  var selection_slot_or_fallback = selection_slot || fallback_block_6(ctx);
  var if_block = ! /*disabled*/ctx[11] && ! /*multiFullItemClearable*/ctx[10] && _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__["default"] && create_if_block_6(ctx);
  function click_handler_1() {
    return (/*click_handler_1*/ctx[92]( /*i*/ctx[127])
    );
  }
  return {
    c: function c() {
      div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
      if (selection_slot_or_fallback) selection_slot_or_fallback.c();
      t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      if (if_block) if_block.c();
      t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span, "class", "multi-item-text svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "multi-item svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "active", /*activeValue*/ctx[26] === /*i*/ctx[127]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "disabled", /*disabled*/ctx[11]);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, span);
      if (selection_slot_or_fallback) {
        selection_slot_or_fallback.m(span, null);
      }
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t0);
      if (if_block) if_block.m(div, null);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t1);
      current = true;
      if (!mounted) {
        dispose = [(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div, "click", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(click_handler_1)), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div, "keydown", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)( /*keydown_handler_1*/ctx[84])))];
        mounted = true;
      }
    },
    p: function p(new_ctx, dirty) {
      ctx = new_ctx;
      if (selection_slot) {
        if (selection_slot.p && (!current || dirty[0] & /*value*/8 | dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(selection_slot, selection_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(selection_slot_template, /*$$scope*/ctx[81], dirty, get_selection_slot_changes), get_selection_slot_context);
        }
      } else {
        if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/4104)) {
          selection_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (! /*disabled*/ctx[11] && ! /*multiFullItemClearable*/ctx[10] && _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__["default"]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*disabled, multiFullItemClearable*/3072) {
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
          }
        } else {
          if_block = create_if_block_6(ctx);
          if_block.c();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
          if_block.m(div, t1);
        }
      } else if (if_block) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, function () {
          if_block = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
      if (!current || dirty[0] & /*activeValue*/67108864) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "active", /*activeValue*/ctx[26] === /*i*/ctx[127]);
      }
      if (!current || dirty[0] & /*disabled*/2048) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "disabled", /*disabled*/ctx[11]);
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(selection_slot_or_fallback, local);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(selection_slot_or_fallback, local);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
      if (selection_slot_or_fallback) selection_slot_or_fallback.d(detaching);
      if (if_block) if_block.d();
      mounted = false;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
    }
  };
}

// (789:8) {#if loading}
function create_if_block_3(ctx) {
  var div;
  var current;
  var loading_icon_slot_template = /*#slots*/ctx[82]["loading-icon"];
  var loading_icon_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(loading_icon_slot_template, ctx, /*$$scope*/ctx[81], get_loading_icon_slot_context);
  var loading_icon_slot_or_fallback = loading_icon_slot || fallback_block_4(ctx);
  return {
    c: function c() {
      div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (loading_icon_slot_or_fallback) loading_icon_slot_or_fallback.c();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "icon loading svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "aria-hidden", "true");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
      if (loading_icon_slot_or_fallback) {
        loading_icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function p(ctx, dirty) {
      if (loading_icon_slot) {
        if (loading_icon_slot.p && (!current || dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(loading_icon_slot, loading_icon_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(loading_icon_slot_template, /*$$scope*/ctx[81], dirty, get_loading_icon_slot_changes), get_loading_icon_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(loading_icon_slot_or_fallback, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(loading_icon_slot_or_fallback, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
      if (loading_icon_slot_or_fallback) loading_icon_slot_or_fallback.d(detaching);
    }
  };
}

// (791:42)                      
function fallback_block_4(ctx) {
  var loadingicon;
  var current;
  loadingicon = new _LoadingIcon_svelte__WEBPACK_IMPORTED_MODULE_7__["default"]({});
  return {
    c: function c() {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(loadingicon.$$.fragment);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(loadingicon, target, anchor);
      current = true;
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(loadingicon.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(loadingicon.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(loadingicon, detaching);
    }
  };
}

// (797:8) {#if showClear}
function create_if_block_2(ctx) {
  var button;
  var current;
  var mounted;
  var dispose;
  var clear_icon_slot_template = /*#slots*/ctx[82]["clear-icon"];
  var clear_icon_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(clear_icon_slot_template, ctx, /*$$scope*/ctx[81], get_clear_icon_slot_context);
  var clear_icon_slot_or_fallback = clear_icon_slot || fallback_block_3(ctx);
  return {
    c: function c() {
      button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
      if (clear_icon_slot_or_fallback) clear_icon_slot_or_fallback.c();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(button, "type", "button");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(button, "class", "icon clear-select svelte-apvs86");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, button, anchor);
      if (clear_icon_slot_or_fallback) {
        clear_icon_slot_or_fallback.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(button, "click", /*handleClear*/ctx[22]);
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      if (clear_icon_slot) {
        if (clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(clear_icon_slot, clear_icon_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(clear_icon_slot_template, /*$$scope*/ctx[81], dirty, get_clear_icon_slot_changes), get_clear_icon_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(clear_icon_slot_or_fallback, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(clear_icon_slot_or_fallback, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(button);
      if (clear_icon_slot_or_fallback) clear_icon_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
}

// (799:40)                      
function fallback_block_3(ctx) {
  var clearicon;
  var current;
  clearicon = new _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__["default"]({});
  return {
    c: function c() {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(clearicon.$$.fragment);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(clearicon, target, anchor);
      current = true;
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(clearicon.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(clearicon.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(clearicon, detaching);
    }
  };
}

// (805:8) {#if showChevron}
function create_if_block_1(ctx) {
  var div;
  var current;
  var chevron_icon_slot_template = /*#slots*/ctx[82]["chevron-icon"];
  var chevron_icon_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(chevron_icon_slot_template, ctx, /*$$scope*/ctx[81], get_chevron_icon_slot_context);
  var chevron_icon_slot_or_fallback = chevron_icon_slot || fallback_block_2(ctx);
  return {
    c: function c() {
      div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (chevron_icon_slot_or_fallback) chevron_icon_slot_or_fallback.c();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "icon chevron svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "aria-hidden", "true");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
      if (chevron_icon_slot_or_fallback) {
        chevron_icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function p(ctx, dirty) {
      if (chevron_icon_slot) {
        if (chevron_icon_slot.p && (!current || dirty[0] & /*listOpen*/64 | dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(chevron_icon_slot, chevron_icon_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(chevron_icon_slot_template, /*$$scope*/ctx[81], dirty, get_chevron_icon_slot_changes), get_chevron_icon_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(chevron_icon_slot_or_fallback, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(chevron_icon_slot_or_fallback, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
      if (chevron_icon_slot_or_fallback) chevron_icon_slot_or_fallback.d(detaching);
    }
  };
}

// (807:53)                      
function fallback_block_2(ctx) {
  var chevronicon;
  var current;
  chevronicon = new _ChevronIcon_svelte__WEBPACK_IMPORTED_MODULE_5__["default"]({});
  return {
    c: function c() {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(chevronicon.$$.fragment);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(chevronicon, target, anchor);
      current = true;
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(chevronicon.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(chevronicon.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(chevronicon, detaching);
    }
  };
}

// (814:38)          
function fallback_block_1(ctx) {
  var input_1;
  var input_1_value_value;
  return {
    c: function c() {
      input_1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(input_1, "name", /*name*/ctx[8]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(input_1, "type", "hidden");
      input_1.value = input_1_value_value = /*value*/ctx[3] ? JSON.stringify( /*value*/ctx[3]) : null;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(input_1, "class", "svelte-apvs86");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, input_1, anchor);
    },
    p: function p(ctx, dirty) {
      if (dirty[0] & /*name*/256) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(input_1, "name", /*name*/ctx[8]);
      }
      if (dirty[0] & /*value*/8 && input_1_value_value !== (input_1_value_value = /*value*/ctx[3] ? JSON.stringify( /*value*/ctx[3]) : null)) {
        input_1.value = input_1_value_value;
      }
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(input_1);
    }
  };
}

// (818:4) {#if required && (!value || value.length === 0)}
function create_if_block(ctx) {
  var current;
  var required_slot_template = /*#slots*/ctx[82].required;
  var required_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(required_slot_template, ctx, /*$$scope*/ctx[81], get_required_slot_context);
  var required_slot_or_fallback = required_slot || fallback_block(ctx);
  return {
    c: function c() {
      if (required_slot_or_fallback) required_slot_or_fallback.c();
    },
    m: function m(target, anchor) {
      if (required_slot_or_fallback) {
        required_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function p(ctx, dirty) {
      if (required_slot) {
        if (required_slot.p && (!current || dirty[0] & /*value*/8 | dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(required_slot, required_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(required_slot_template, /*$$scope*/ctx[81], dirty, get_required_slot_changes), get_required_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(required_slot_or_fallback, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(required_slot_or_fallback, local);
      current = false;
    },
    d: function d(detaching) {
      if (required_slot_or_fallback) required_slot_or_fallback.d(detaching);
    }
  };
}

// (819:38)              
function fallback_block(ctx) {
  var select;
  return {
    c: function c() {
      select = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("select");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(select, "class", "required svelte-apvs86");
      select.required = true;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(select, "tabindex", "-1");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(select, "aria-hidden", "true");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, select, anchor);
    },
    p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(select);
    }
  };
}
function create_fragment(ctx) {
  var div3;
  var t0;
  var span;
  var t1;
  var div0;
  var t2;
  var div1;
  var t3;
  var input_1;
  var input_1_readonly_value;
  var t4;
  var div2;
  var t5;
  var t6;
  var t7;
  var t8;
  var div3_class_value;
  var floatingRef_action;
  var current;
  var mounted;
  var dispose;
  var if_block0 = /*listOpen*/ctx[6] && create_if_block_8(ctx);
  var if_block1 = /*focused*/ctx[2] && create_if_block_7(ctx);
  var prepend_slot_template = /*#slots*/ctx[82].prepend;
  var prepend_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(prepend_slot_template, ctx, /*$$scope*/ctx[81], get_prepend_slot_context);
  var if_block2 = /*hasValue*/ctx[25] && create_if_block_4(ctx);
  var input_1_levels = [{
    readOnly: input_1_readonly_value = ! /*searchable*/ctx[17]
  }, /*_inputAttributes*/ctx[27], {
    placeholder: /*placeholderText*/ctx[33]
  }, {
    style: /*inputStyles*/ctx[18]
  }, {
    disabled: /*disabled*/ctx[11]
  }];
  var input_data = {};
  for (var i = 0; i < input_1_levels.length; i += 1) {
    input_data = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.assign)(input_data, input_1_levels[i]);
  }
  var if_block3 = /*loading*/ctx[5] && create_if_block_3(ctx);
  var if_block4 = /*showClear*/ctx[34] && create_if_block_2(ctx);
  var if_block5 = /*showChevron*/ctx[20] && create_if_block_1(ctx);
  var input_hidden_slot_template = /*#slots*/ctx[82]["input-hidden"];
  var input_hidden_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(input_hidden_slot_template, ctx, /*$$scope*/ctx[81], get_input_hidden_slot_context);
  var input_hidden_slot_or_fallback = input_hidden_slot || fallback_block_1(ctx);
  var if_block6 = /*required*/ctx[16] && (! /*value*/ctx[3] || /*value*/ctx[3].length === 0) && create_if_block(ctx);
  return {
    c: function c() {
      div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (if_block0) if_block0.c();
      t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
      if (if_block1) if_block1.c();
      t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (prepend_slot) prepend_slot.c();
      t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (if_block2) if_block2.c();
      t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      input_1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
      t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      if (if_block3) if_block3.c();
      t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      if (if_block4) if_block4.c();
      t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      if (if_block5) if_block5.c();
      t7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      if (input_hidden_slot_or_fallback) input_hidden_slot_or_fallback.c();
      t8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      if (if_block6) if_block6.c();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span, "aria-live", "polite");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span, "aria-atomic", "false");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span, "aria-relevant", "additions text");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span, "class", "a11y-text svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div0, "class", "prepend svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_attributes)(input_1, input_data);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(input_1, "svelte-apvs86", true);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div1, "class", "value-container svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div2, "class", "indicators svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div3, "class", div3_class_value = "svelte-select " + /*containerClasses*/ctx[21] + " svelte-apvs86");
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div3, "style", /*containerStyles*/ctx[14]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "multi", /*multiple*/ctx[9]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "disabled", /*disabled*/ctx[11]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "focused", /*focused*/ctx[2]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "list-open", /*listOpen*/ctx[6]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "show-chevron", /*showChevron*/ctx[20]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "error", /*hasError*/ctx[15]);
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div3, anchor);
      if (if_block0) if_block0.m(div3, null);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, t0);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, span);
      if (if_block1) if_block1.m(span, null);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, t1);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, div0);
      if (prepend_slot) {
        prepend_slot.m(div0, null);
      }
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, t2);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, div1);
      if (if_block2) if_block2.m(div1, null);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div1, t3);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div1, input_1);
      if (input_1.autofocus) input_1.focus();
      /*input_1_binding*/
      ctx[93](input_1);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input_1, /*filterText*/ctx[4]);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, t4);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, div2);
      if (if_block3) if_block3.m(div2, null);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div2, t5);
      if (if_block4) if_block4.m(div2, null);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div2, t6);
      if (if_block5) if_block5.m(div2, null);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, t7);
      if (input_hidden_slot_or_fallback) {
        input_hidden_slot_or_fallback.m(div3, null);
      }
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div3, t8);
      if (if_block6) if_block6.m(div3, null);
      /*div3_binding*/
      ctx[95](div3);
      current = true;
      if (!mounted) {
        dispose = [(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(window, "click", /*handleClickOutside*/ctx[42]), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(window, "keydown", /*handleKeyDown*/ctx[37]), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(input_1, "keydown", /*handleKeyDown*/ctx[37]), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(input_1, "blur", /*handleBlur*/ctx[39]), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(input_1, "focus", /*handleFocus*/ctx[38]), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(input_1, "input", /*input_1_input_handler*/ctx[94]), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div3, "pointerup", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)( /*handleClick*/ctx[40])), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div3, "mousedown", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)( /*mousedown_handler*/ctx[83])), (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.action_destroyer)(floatingRef_action = /*floatingRef*/ctx[48].call(null, div3))];
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      if ( /*listOpen*/ctx[6]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & /*listOpen*/64) {
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx);
          if_block0.c();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
          if_block0.m(div3, t0);
        }
      } else if (if_block0) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0, 1, 1, function () {
          if_block0 = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
      if ( /*focused*/ctx[2]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_7(ctx);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (prepend_slot) {
        if (prepend_slot.p && (!current || dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(prepend_slot, prepend_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(prepend_slot_template, /*$$scope*/ctx[81], dirty, get_prepend_slot_changes), get_prepend_slot_context);
        }
      }
      if ( /*hasValue*/ctx[25]) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty[0] & /*hasValue*/33554432) {
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4(ctx);
          if_block2.c();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);
          if_block2.m(div1, t3);
        }
      } else if (if_block2) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2, 1, 1, function () {
          if_block2 = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_attributes)(input_1, input_data = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_spread_update)(input_1_levels, [(!current || dirty[0] & /*searchable*/131072 && input_1_readonly_value !== (input_1_readonly_value = ! /*searchable*/ctx[17])) && {
        readOnly: input_1_readonly_value
      }, dirty[0] & /*_inputAttributes*/134217728 && /*_inputAttributes*/ctx[27], (!current || dirty[1] & /*placeholderText*/4) && {
        placeholder: /*placeholderText*/ctx[33]
      }, (!current || dirty[0] & /*inputStyles*/262144) && {
        style: /*inputStyles*/ctx[18]
      }, (!current || dirty[0] & /*disabled*/2048) && {
        disabled: /*disabled*/ctx[11]
      }]));
      if (dirty[0] & /*filterText*/16 && input_1.value !== /*filterText*/ctx[4]) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input_1, /*filterText*/ctx[4]);
      }
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(input_1, "svelte-apvs86", true);
      if ( /*loading*/ctx[5]) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
          if (dirty[0] & /*loading*/32) {
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3(ctx);
          if_block3.c();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3, 1);
          if_block3.m(div2, t5);
        }
      } else if (if_block3) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block3, 1, 1, function () {
          if_block3 = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
      if ( /*showClear*/ctx[34]) {
        if (if_block4) {
          if_block4.p(ctx, dirty);
          if (dirty[1] & /*showClear*/8) {
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2(ctx);
          if_block4.c();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block4, 1);
          if_block4.m(div2, t6);
        }
      } else if (if_block4) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block4, 1, 1, function () {
          if_block4 = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
      if ( /*showChevron*/ctx[20]) {
        if (if_block5) {
          if_block5.p(ctx, dirty);
          if (dirty[0] & /*showChevron*/1048576) {
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1(ctx);
          if_block5.c();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block5, 1);
          if_block5.m(div2, null);
        }
      } else if (if_block5) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block5, 1, 1, function () {
          if_block5 = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
      if (input_hidden_slot) {
        if (input_hidden_slot.p && (!current || dirty[0] & /*value*/8 | dirty[2] & /*$$scope*/524288)) {
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(input_hidden_slot, input_hidden_slot_template, ctx, /*$$scope*/ctx[81], !current ? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)( /*$$scope*/ctx[81]) : (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(input_hidden_slot_template, /*$$scope*/ctx[81], dirty, get_input_hidden_slot_changes), get_input_hidden_slot_context);
        }
      } else {
        if (input_hidden_slot_or_fallback && input_hidden_slot_or_fallback.p && (!current || dirty[0] & /*name, value*/264)) {
          input_hidden_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if ( /*required*/ctx[16] && (! /*value*/ctx[3] || /*value*/ctx[3].length === 0)) {
        if (if_block6) {
          if_block6.p(ctx, dirty);
          if (dirty[0] & /*required, value*/65544) {
            (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block(ctx);
          if_block6.c();
          (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block6, 1);
          if_block6.m(div3, null);
        }
      } else if (if_block6) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block6, 1, 1, function () {
          if_block6 = null;
        });
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
      }
      if (!current || dirty[0] & /*containerClasses*/2097152 && div3_class_value !== (div3_class_value = "svelte-select " + /*containerClasses*/ctx[21] + " svelte-apvs86")) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*containerStyles*/16384) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div3, "style", /*containerStyles*/ctx[14]);
      }
      if (!current || dirty[0] & /*containerClasses, multiple*/2097664) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "multi", /*multiple*/ctx[9]);
      }
      if (!current || dirty[0] & /*containerClasses, disabled*/2099200) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "disabled", /*disabled*/ctx[11]);
      }
      if (!current || dirty[0] & /*containerClasses, focused*/2097156) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "focused", /*focused*/ctx[2]);
      }
      if (!current || dirty[0] & /*containerClasses, listOpen*/2097216) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "list-open", /*listOpen*/ctx[6]);
      }
      if (!current || dirty[0] & /*containerClasses, showChevron*/3145728) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "show-chevron", /*showChevron*/ctx[20]);
      }
      if (!current || dirty[0] & /*containerClasses, hasError*/2129920) {
        (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "error", /*hasError*/ctx[15]);
      }
    },
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(prepend_slot, local);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block4);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block5);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(input_hidden_slot_or_fallback, local);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block6);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(prepend_slot, local);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block3);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block4);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block5);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(input_hidden_slot_or_fallback, local);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block6);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div3);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (prepend_slot) prepend_slot.d(detaching);
      if (if_block2) if_block2.d();
      /*input_1_binding*/
      ctx[93](null);
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
      if (if_block5) if_block5.d();
      if (input_hidden_slot_or_fallback) input_hidden_slot_or_fallback.d(detaching);
      if (if_block6) if_block6.d();
      /*div3_binding*/
      ctx[95](null);
      mounted = false;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
    }
  };
}
function convertStringItemsToObjects(_items) {
  return _items.map(function (item, index) {
    return {
      index: index,
      value: item,
      label: "".concat(item)
    };
  });
}
function isItemFirst(itemIndex) {
  return itemIndex === 0;
}
function isItemSelectable(item) {
  return item.groupHeader && item.selectable || item.selectable || !item.hasOwnProperty('selectable');
}
function instance($$self, $$props, $$invalidate) {
  var hasValue;
  var hideSelectedItem;
  var showClear;
  var placeholderText;
  var ariaSelection;
  var ariaContext;
  var filteredItems;
  var listDom;
  var scrollToHoverItem;
  var _$$props$$$slots = $$props.$$slots,
    slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
    $$scope = $$props.$$scope;
  var $$slots = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.compute_slots)(slots);
  var dispatch = (0,svelte__WEBPACK_IMPORTED_MODULE_1__.createEventDispatcher)();
  var _$$props$justValue = $$props.justValue,
    justValue = _$$props$justValue === void 0 ? null : _$$props$justValue;
  var _$$props$filter = $$props.filter,
    filter = _$$props$filter === void 0 ? _filter__WEBPACK_IMPORTED_MODULE_3__["default"] : _$$props$filter;
  var _$$props$getItems = $$props.getItems,
    getItems = _$$props$getItems === void 0 ? _get_items__WEBPACK_IMPORTED_MODULE_4__["default"] : _$$props$getItems;
  var _$$props$id = $$props.id,
    id = _$$props$id === void 0 ? null : _$$props$id;
  var _$$props$name = $$props.name,
    name = _$$props$name === void 0 ? null : _$$props$name;
  var _$$props$container = $$props.container,
    container = _$$props$container === void 0 ? undefined : _$$props$container;
  var _$$props$input = $$props.input,
    input = _$$props$input === void 0 ? undefined : _$$props$input;
  var _$$props$multiple = $$props.multiple,
    multiple = _$$props$multiple === void 0 ? false : _$$props$multiple;
  var _$$props$multiFullIte = $$props.multiFullItemClearable,
    multiFullItemClearable = _$$props$multiFullIte === void 0 ? false : _$$props$multiFullIte;
  var _$$props$disabled = $$props.disabled,
    disabled = _$$props$disabled === void 0 ? false : _$$props$disabled;
  var _$$props$focused = $$props.focused,
    focused = _$$props$focused === void 0 ? false : _$$props$focused;
  var _$$props$value = $$props.value,
    value = _$$props$value === void 0 ? null : _$$props$value;
  var _$$props$filterText = $$props.filterText,
    filterText = _$$props$filterText === void 0 ? '' : _$$props$filterText;
  var _$$props$placeholder = $$props.placeholder,
    placeholder = _$$props$placeholder === void 0 ? 'Please select' : _$$props$placeholder;
  var _$$props$placeholderA = $$props.placeholderAlwaysShow,
    placeholderAlwaysShow = _$$props$placeholderA === void 0 ? false : _$$props$placeholderA;
  var _$$props$items = $$props.items,
    items = _$$props$items === void 0 ? null : _$$props$items;
  var _$$props$label = $$props.label,
    label = _$$props$label === void 0 ? 'label' : _$$props$label;
  var _$$props$itemFilter = $$props.itemFilter,
    itemFilter = _$$props$itemFilter === void 0 ? function (label, filterText, option) {
      return "".concat(label).toLowerCase().includes(filterText.toLowerCase());
    } : _$$props$itemFilter;
  var _$$props$groupBy = $$props.groupBy,
    groupBy = _$$props$groupBy === void 0 ? undefined : _$$props$groupBy;
  var _$$props$groupFilter = $$props.groupFilter,
    groupFilter = _$$props$groupFilter === void 0 ? function (groups) {
      return groups;
    } : _$$props$groupFilter;
  var _$$props$groupHeaderS = $$props.groupHeaderSelectable,
    groupHeaderSelectable = _$$props$groupHeaderS === void 0 ? false : _$$props$groupHeaderS;
  var _$$props$itemId = $$props.itemId,
    itemId = _$$props$itemId === void 0 ? 'value' : _$$props$itemId;
  var _$$props$loadOptions = $$props.loadOptions,
    loadOptions = _$$props$loadOptions === void 0 ? undefined : _$$props$loadOptions;
  var _$$props$containerSty = $$props.containerStyles,
    containerStyles = _$$props$containerSty === void 0 ? '' : _$$props$containerSty;
  var _$$props$hasError = $$props.hasError,
    hasError = _$$props$hasError === void 0 ? false : _$$props$hasError;
  var _$$props$filterSelect = $$props.filterSelectedItems,
    filterSelectedItems = _$$props$filterSelect === void 0 ? true : _$$props$filterSelect;
  var _$$props$required = $$props.required,
    required = _$$props$required === void 0 ? false : _$$props$required;
  var _$$props$closeListOnC = $$props.closeListOnChange,
    closeListOnChange = _$$props$closeListOnC === void 0 ? true : _$$props$closeListOnC;
  var _$$props$createGroupH = $$props.createGroupHeaderItem,
    createGroupHeaderItem = _$$props$createGroupH === void 0 ? function (groupValue, item) {
      return _defineProperty({
        value: groupValue
      }, label, groupValue);
    } : _$$props$createGroupH;
  var getFilteredItems = function getFilteredItems() {
    return filteredItems;
  };
  var _$$props$searchable = $$props.searchable,
    searchable = _$$props$searchable === void 0 ? true : _$$props$searchable;
  var _$$props$inputStyles = $$props.inputStyles,
    inputStyles = _$$props$inputStyles === void 0 ? '' : _$$props$inputStyles;
  var _$$props$clearable = $$props.clearable,
    clearable = _$$props$clearable === void 0 ? true : _$$props$clearable;
  var _$$props$loading = $$props.loading,
    loading = _$$props$loading === void 0 ? false : _$$props$loading;
  var _$$props$listOpen = $$props.listOpen,
    listOpen = _$$props$listOpen === void 0 ? false : _$$props$listOpen;
  var timeout;
  var _$$props$debounce = $$props.debounce,
    debounce = _$$props$debounce === void 0 ? function (fn) {
      var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      clearTimeout(timeout);
      timeout = setTimeout(fn, wait);
    } : _$$props$debounce;
  var _$$props$debounceWait = $$props.debounceWait,
    debounceWait = _$$props$debounceWait === void 0 ? 300 : _$$props$debounceWait;
  var _$$props$hideEmptySta = $$props.hideEmptyState,
    hideEmptyState = _$$props$hideEmptySta === void 0 ? false : _$$props$hideEmptySta;
  var _$$props$inputAttribu = $$props.inputAttributes,
    inputAttributes = _$$props$inputAttribu === void 0 ? {} : _$$props$inputAttribu;
  var _$$props$listAutoWidt = $$props.listAutoWidth,
    listAutoWidth = _$$props$listAutoWidt === void 0 ? true : _$$props$listAutoWidt;
  var _$$props$showChevron = $$props.showChevron,
    showChevron = _$$props$showChevron === void 0 ? false : _$$props$showChevron;
  var _$$props$listOffset = $$props.listOffset,
    listOffset = _$$props$listOffset === void 0 ? 5 : _$$props$listOffset;
  var _$$props$hoverItemInd = $$props.hoverItemIndex,
    hoverItemIndex = _$$props$hoverItemInd === void 0 ? 0 : _$$props$hoverItemInd;
  var _$$props$floatingConf = $$props.floatingConfig,
    floatingConfig = _$$props$floatingConf === void 0 ? {} : _$$props$floatingConf;
  var _$$props$class = $$props["class"],
    containerClasses = _$$props$class === void 0 ? '' : _$$props$class;
  var activeValue;
  var prev_value;
  var prev_filterText;
  var prev_multiple;
  function setValue() {
    if (typeof value === 'string') {
      var _ref2;
      var item = (items || []).find(function (item) {
        return item[itemId] === value;
      });
      $$invalidate(3, value = item || (_ref2 = {}, _defineProperty(_ref2, itemId, value), _defineProperty(_ref2, "label", value), _ref2));
    } else if (multiple && Array.isArray(value) && value.length > 0) {
      $$invalidate(3, value = value.map(function (item) {
        return typeof item === 'string' ? {
          value: item,
          label: item
        } : item;
      }));
    }
  }
  var _inputAttributes;
  function assignInputAttributes() {
    $$invalidate(27, _inputAttributes = Object.assign({
      autocapitalize: 'none',
      autocomplete: 'off',
      autocorrect: 'off',
      spellcheck: false,
      tabindex: 0,
      type: 'text',
      'aria-autocomplete': 'list'
    }, inputAttributes));
    if (id) {
      $$invalidate(27, _inputAttributes['id'] = id, _inputAttributes);
    }
    if (!searchable) {
      $$invalidate(27, _inputAttributes['readonly'] = true, _inputAttributes);
    }
  }
  function filterGroupedItems(_items) {
    var groupValues = [];
    var groups = {};
    _items.forEach(function (item) {
      var groupValue = groupBy(item);
      if (!groupValues.includes(groupValue)) {
        groupValues.push(groupValue);
        groups[groupValue] = [];
        if (groupValue) {
          groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
            id: groupValue,
            groupHeader: true,
            selectable: groupHeaderSelectable
          }));
        }
      }
      groups[groupValue].push(Object.assign({
        groupItem: !!groupValue
      }, item));
    });
    var sortedGroupedItems = [];
    groupFilter(groupValues).forEach(function (groupValue) {
      if (groups[groupValue]) sortedGroupedItems.push.apply(sortedGroupedItems, _toConsumableArray(groups[groupValue]));
    });
    return sortedGroupedItems;
  }
  function dispatchSelectedItem() {
    if (multiple) {
      if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
        if (checkValueForDuplicates()) {
          dispatch('input', value);
        }
      }
      return;
    }
    if (!prev_value || JSON.stringify(value[itemId]) !== JSON.stringify(prev_value[itemId])) {
      dispatch('input', value);
    }
  }
  function setupMulti() {
    if (value) {
      if (Array.isArray(value)) {
        $$invalidate(3, value = _toConsumableArray(value));
      } else {
        $$invalidate(3, value = [value]);
      }
    }
  }
  function setupSingle() {
    if (value) $$invalidate(3, value = null);
  }
  function setValueIndexAsHoverIndex() {
    var valueIndex = filteredItems.findIndex(function (i) {
      return i[itemId] === value[itemId];
    });
    checkHoverSelectable(valueIndex, true);
  }
  function dispatchHover(i) {
    dispatch('hoverItem', i);
  }
  function checkHoverSelectable() {
    var startingIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var ignoreGroup = arguments.length > 1 ? arguments[1] : undefined;
    $$invalidate(7, hoverItemIndex = startingIndex < 0 ? 0 : startingIndex);
    if (!ignoreGroup && groupBy && filteredItems[hoverItemIndex] && !filteredItems[hoverItemIndex].selectable) {
      setHoverIndex(1);
    }
  }
  function setupFilterText() {
    if (!loadOptions && filterText.length === 0) return;
    if (loadOptions) {
      debounce( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var res;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              $$invalidate(5, loading = true);
              _context.next = 3;
              return getItems({
                dispatch: dispatch,
                loadOptions: loadOptions,
                convertStringItemsToObjects: convertStringItemsToObjects,
                filterText: filterText
              });
            case 3:
              res = _context.sent;
              if (res) {
                $$invalidate(5, loading = res.loading);
                $$invalidate(6, listOpen = listOpen ? res.listOpen : filterText.length > 0 ? true : false);
                $$invalidate(2, focused = listOpen && res.focused);
                $$invalidate(51, items = groupBy ? filterGroupedItems(res.filteredItems) : res.filteredItems);
              } else {
                $$invalidate(5, loading = false);
                $$invalidate(2, focused = true);
                $$invalidate(6, listOpen = true);
              }
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })), debounceWait);
    } else {
      $$invalidate(6, listOpen = true);
      if (multiple) {
        $$invalidate(26, activeValue = undefined);
      }
    }
  }
  function handleFilterEvent(items) {
    if (listOpen) dispatch('filter', items);
  }
  (0,svelte__WEBPACK_IMPORTED_MODULE_1__.beforeUpdate)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          $$invalidate(77, prev_value = value);
          $$invalidate(78, prev_filterText = filterText);
          $$invalidate(79, prev_multiple = multiple);
        case 3:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  })));
  function computeJustValue() {
    if (multiple) return value ? value.map(function (item) {
      return item[itemId];
    }) : null;
    return value ? value[itemId] : value;
  }
  function checkValueForDuplicates() {
    var noDuplicates = true;
    if (value) {
      var ids = [];
      var uniqueValues = [];
      value.forEach(function (val) {
        if (!ids.includes(val[itemId])) {
          ids.push(val[itemId]);
          uniqueValues.push(val);
        } else {
          noDuplicates = false;
        }
      });
      if (!noDuplicates) $$invalidate(3, value = uniqueValues);
    }
    return noDuplicates;
  }
  function findItem(selection) {
    var matchTo = selection ? selection[itemId] : value[itemId];
    return items.find(function (item) {
      return item[itemId] === matchTo;
    });
  }
  function updateValueDisplay(items) {
    if (!items || items.length === 0 || items.some(function (item) {
      return _typeof(item) !== 'object';
    })) return;
    if (!value || (multiple ? value.some(function (selection) {
      return !selection || !selection[itemId];
    }) : !value[itemId])) return;
    if (Array.isArray(value)) {
      $$invalidate(3, value = value.map(function (selection) {
        return findItem(selection) || selection;
      }));
    } else {
      $$invalidate(3, value = findItem() || value);
    }
  }
  function handleMultiItemClear(_x) {
    return _handleMultiItemClear.apply(this, arguments);
  }
  function _handleMultiItemClear() {
    _handleMultiItemClear = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(i) {
      var itemToRemove;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            itemToRemove = value[i];
            if (value.length === 1) {
              $$invalidate(3, value = undefined);
            } else {
              $$invalidate(3, value = value.filter(function (item) {
                return item !== itemToRemove;
              }));
            }
            dispatch('clear', itemToRemove);
          case 3:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _handleMultiItemClear.apply(this, arguments);
  }
  function handleKeyDown(e) {
    if (!focused) return;
    e.stopPropagation();
    switch (e.key) {
      case 'Escape':
        e.preventDefault();
        closeList();
        break;
      case 'Enter':
        e.preventDefault();
        if (listOpen) {
          if (filteredItems.length === 0) break;
          var hoverItem = filteredItems[hoverItemIndex];
          if (value && !multiple && value[itemId] === hoverItem[itemId]) {
            closeList();
            break;
          } else {
            handleSelect(filteredItems[hoverItemIndex]);
          }
        }
        break;
      case 'ArrowDown':
        e.preventDefault();
        if (listOpen) {
          setHoverIndex(1);
        } else {
          $$invalidate(6, listOpen = true);
          $$invalidate(26, activeValue = undefined);
        }
        break;
      case 'ArrowUp':
        e.preventDefault();
        if (listOpen) {
          setHoverIndex(-1);
        } else {
          $$invalidate(6, listOpen = true);
          $$invalidate(26, activeValue = undefined);
        }
        break;
      case 'Tab':
        if (listOpen && focused) {
          if (filteredItems.length === 0 || value && value[itemId] === filteredItems[hoverItemIndex][itemId]) return closeList();
          e.preventDefault();
          handleSelect(filteredItems[hoverItemIndex]);
          closeList();
        }
        break;
      case 'Backspace':
        if (!multiple || filterText.length > 0) return;
        if (multiple && value && value.length > 0) {
          handleMultiItemClear(activeValue !== undefined ? activeValue : value.length - 1);
          if (activeValue === 0 || activeValue === undefined) break;
          $$invalidate(26, activeValue = value.length > activeValue ? activeValue - 1 : undefined);
        }
        break;
      case 'ArrowLeft':
        if (!value || !multiple || filterText.length > 0) return;
        if (activeValue === undefined) {
          $$invalidate(26, activeValue = value.length - 1);
        } else if (value.length > activeValue && activeValue !== 0) {
          $$invalidate(26, activeValue -= 1);
        }
        break;
      case 'ArrowRight':
        if (!value || !multiple || filterText.length > 0 || activeValue === undefined) return;
        if (activeValue === value.length - 1) {
          $$invalidate(26, activeValue = undefined);
        } else if (activeValue < value.length - 1) {
          $$invalidate(26, activeValue += 1);
        }
        break;
    }
  }
  function handleFocus(e) {
    var _document;
    if (focused && input === ((_document = document) === null || _document === void 0 ? void 0 : _document.activeElement)) return;
    if (e) dispatch('focus', e);
    input.focus();
    $$invalidate(2, focused = true);
  }
  function handleBlur(_x2) {
    return _handleBlur.apply(this, arguments);
  }
  function _handleBlur() {
    _handleBlur = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(e) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            if (!isScrolling) {
              _context4.next = 2;
              break;
            }
            return _context4.abrupt("return");
          case 2:
            if (listOpen || focused) {
              dispatch('blur', e);
              closeList();
              $$invalidate(2, focused = false);
              $$invalidate(26, activeValue = undefined);
              input.blur();
            }
          case 3:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return _handleBlur.apply(this, arguments);
  }
  function handleClick() {
    if (disabled) return;
    $$invalidate(6, listOpen = !listOpen);
  }
  function handleClear() {
    dispatch('clear', value);
    $$invalidate(3, value = undefined);
    closeList();
    handleFocus();
  }
  (0,svelte__WEBPACK_IMPORTED_MODULE_1__.onMount)(function () {
    if (listOpen) $$invalidate(2, focused = true);
    if (focused && input) input.focus();
  });
  function itemSelected(selection) {
    if (selection) {
      $$invalidate(4, filterText = '');
      var item = Object.assign({}, selection);
      if (item.groupHeader && !item.selectable) return;
      $$invalidate(3, value = multiple ? value ? value.concat([item]) : [item] : $$invalidate(3, value = item));
      setTimeout(function () {
        if (closeListOnChange) closeList();
        $$invalidate(26, activeValue = undefined);
        dispatch('change', value);
        dispatch('select', selection);
      });
    }
  }
  function closeList() {
    $$invalidate(4, filterText = '');
    $$invalidate(6, listOpen = false);
  }
  var _$$props$ariaValues = $$props.ariaValues,
    ariaValues = _$$props$ariaValues === void 0 ? function (values) {
      return "Option ".concat(values, ", selected.");
    } : _$$props$ariaValues;
  var _$$props$ariaListOpen = $$props.ariaListOpen,
    ariaListOpen = _$$props$ariaListOpen === void 0 ? function (label, count) {
      return "You are currently focused on option ".concat(label, ". There are ").concat(count, " results available.");
    } : _$$props$ariaListOpen;
  var _$$props$ariaFocused = $$props.ariaFocused,
    ariaFocused = _$$props$ariaFocused === void 0 ? function () {
      return "Select is focused, type to refine list, press down to open the menu.";
    } : _$$props$ariaFocused;
  function handleAriaSelection(_multiple) {
    var selected = undefined;
    if (_multiple && value.length > 0) {
      selected = value.map(function (v) {
        return v[label];
      }).join(', ');
    } else {
      selected = value[label];
    }
    return ariaValues(selected);
  }
  function handleAriaContent() {
    if (!filteredItems || filteredItems.length === 0) return '';
    var _item = filteredItems[hoverItemIndex];
    if (listOpen && _item) {
      var count = filteredItems ? filteredItems.length : 0;
      return ariaListOpen(_item[label], count);
    } else {
      return ariaFocused();
    }
  }
  var list = null;
  var isScrollingTimer;
  function handleListScroll() {
    clearTimeout(isScrollingTimer);
    isScrollingTimer = setTimeout(function () {
      isScrolling = false;
    }, 100);
  }
  function handleClickOutside(event) {
    var _list;
    if (!listOpen && !focused && container && !container.contains(event.target) && !((_list = list) !== null && _list !== void 0 && _list.contains(event.target))) {
      handleBlur();
    }
  }
  (0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(function () {
    var _list2;
    (_list2 = list) === null || _list2 === void 0 ? void 0 : _list2.remove();
  });
  var isScrolling = false;
  function handleSelect(item) {
    if (!item || item.selectable === false) return;
    itemSelected(item);
  }
  function handleHover(i) {
    if (isScrolling) return;
    $$invalidate(7, hoverItemIndex = i);
  }
  function handleItemClick(args) {
    var item = args.item,
      i = args.i;
    if ((item === null || item === void 0 ? void 0 : item.selectable) === false) return;
    if (value && !multiple && value[itemId] === item[itemId]) return closeList();
    if (isItemSelectable(item)) {
      $$invalidate(7, hoverItemIndex = i);
      handleSelect(item);
    }
  }
  function setHoverIndex(increment) {
    var selectableFilteredItems = filteredItems.filter(function (item) {
      return !Object.hasOwn(item, 'selectable') || item.selectable === true;
    });
    if (selectableFilteredItems.length === 0) {
      return $$invalidate(7, hoverItemIndex = 0);
    }
    if (increment > 0 && hoverItemIndex === filteredItems.length - 1) {
      $$invalidate(7, hoverItemIndex = 0);
    } else if (increment < 0 && hoverItemIndex === 0) {
      $$invalidate(7, hoverItemIndex = filteredItems.length - 1);
    } else {
      $$invalidate(7, hoverItemIndex = hoverItemIndex + increment);
    }
    var hover = filteredItems[hoverItemIndex];
    if (hover && hover.selectable === false) {
      if (increment === 1 || increment === -1) setHoverIndex(increment);
      return;
    }
  }
  function isItemActive(item, value, itemId) {
    if (multiple) return;
    return value && value[itemId] === item[itemId];
  }
  var activeScroll = scrollAction;
  var hoverScroll = scrollAction;
  function scrollAction(node) {
    return {
      update: function update(args) {
        if (args.scroll) {
          handleListScroll();
          node.scrollIntoView({
            behavior: 'auto',
            block: 'nearest'
          });
        }
      }
    };
  }
  function setListWidth() {
    var _container$getBoundin = container.getBoundingClientRect(),
      width = _container$getBoundin.width;
    $$invalidate(23, list.style.width = listAutoWidth ? width + 'px' : 'auto', list);
  }
  var _floatingConfig = {
    strategy: 'absolute',
    placement: 'bottom-start',
    middleware: [(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__.offset)(listOffset), (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__.flip)(), (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__.shift)()],
    autoUpdate: false
  };
  var _createFloatingAction = (0,svelte_floating_ui__WEBPACK_IMPORTED_MODULE_2__.createFloatingActions)(_floatingConfig),
    _createFloatingAction2 = _slicedToArray(_createFloatingAction, 3),
    floatingRef = _createFloatingAction2[0],
    floatingContent = _createFloatingAction2[1],
    floatingUpdate = _createFloatingAction2[2];
  var prefloat = true;
  function listMounted(list, listOpen) {
    if (!list || !listOpen) return $$invalidate(28, prefloat = true);
    setTimeout(function () {
      $$invalidate(28, prefloat = false);
    }, 0);
  }
  function mousedown_handler(event) {
    svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);
  }
  function keydown_handler_1(event) {
    svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);
  }
  var mouseover_handler = function mouseover_handler(i) {
    return handleHover(i);
  };
  var focus_handler = function focus_handler(i) {
    return handleHover(i);
  };
  var click_handler = function click_handler(item, i) {
    return handleItemClick({
      item: item,
      i: i
    });
  };
  function div_binding($$value) {
    svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](function () {
      list = $$value;
      $$invalidate(23, list);
    });
  }
  var pointerup_handler_1 = function pointerup_handler_1(i) {
    return handleMultiItemClear(i);
  };
  var click_handler_1 = function click_handler_1(i) {
    return multiFullItemClearable ? handleMultiItemClear(i) : {};
  };
  function input_1_binding($$value) {
    svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](function () {
      input = $$value;
      $$invalidate(1, input);
    });
  }
  function input_1_input_handler() {
    filterText = this.value;
    $$invalidate(4, filterText);
  }
  function div3_binding($$value) {
    svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](function () {
      container = $$value;
      $$invalidate(0, container);
    });
  }
  $$self.$$set = function ($$props) {
    if ('justValue' in $$props) $$invalidate(52, justValue = $$props.justValue);
    if ('filter' in $$props) $$invalidate(53, filter = $$props.filter);
    if ('getItems' in $$props) $$invalidate(54, getItems = $$props.getItems);
    if ('id' in $$props) $$invalidate(55, id = $$props.id);
    if ('name' in $$props) $$invalidate(8, name = $$props.name);
    if ('container' in $$props) $$invalidate(0, container = $$props.container);
    if ('input' in $$props) $$invalidate(1, input = $$props.input);
    if ('multiple' in $$props) $$invalidate(9, multiple = $$props.multiple);
    if ('multiFullItemClearable' in $$props) $$invalidate(10, multiFullItemClearable = $$props.multiFullItemClearable);
    if ('disabled' in $$props) $$invalidate(11, disabled = $$props.disabled);
    if ('focused' in $$props) $$invalidate(2, focused = $$props.focused);
    if ('value' in $$props) $$invalidate(3, value = $$props.value);
    if ('filterText' in $$props) $$invalidate(4, filterText = $$props.filterText);
    if ('placeholder' in $$props) $$invalidate(56, placeholder = $$props.placeholder);
    if ('placeholderAlwaysShow' in $$props) $$invalidate(57, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
    if ('items' in $$props) $$invalidate(51, items = $$props.items);
    if ('label' in $$props) $$invalidate(12, label = $$props.label);
    if ('itemFilter' in $$props) $$invalidate(58, itemFilter = $$props.itemFilter);
    if ('groupBy' in $$props) $$invalidate(59, groupBy = $$props.groupBy);
    if ('groupFilter' in $$props) $$invalidate(60, groupFilter = $$props.groupFilter);
    if ('groupHeaderSelectable' in $$props) $$invalidate(61, groupHeaderSelectable = $$props.groupHeaderSelectable);
    if ('itemId' in $$props) $$invalidate(13, itemId = $$props.itemId);
    if ('loadOptions' in $$props) $$invalidate(62, loadOptions = $$props.loadOptions);
    if ('containerStyles' in $$props) $$invalidate(14, containerStyles = $$props.containerStyles);
    if ('hasError' in $$props) $$invalidate(15, hasError = $$props.hasError);
    if ('filterSelectedItems' in $$props) $$invalidate(63, filterSelectedItems = $$props.filterSelectedItems);
    if ('required' in $$props) $$invalidate(16, required = $$props.required);
    if ('closeListOnChange' in $$props) $$invalidate(64, closeListOnChange = $$props.closeListOnChange);
    if ('createGroupHeaderItem' in $$props) $$invalidate(65, createGroupHeaderItem = $$props.createGroupHeaderItem);
    if ('searchable' in $$props) $$invalidate(17, searchable = $$props.searchable);
    if ('inputStyles' in $$props) $$invalidate(18, inputStyles = $$props.inputStyles);
    if ('clearable' in $$props) $$invalidate(67, clearable = $$props.clearable);
    if ('loading' in $$props) $$invalidate(5, loading = $$props.loading);
    if ('listOpen' in $$props) $$invalidate(6, listOpen = $$props.listOpen);
    if ('debounce' in $$props) $$invalidate(68, debounce = $$props.debounce);
    if ('debounceWait' in $$props) $$invalidate(69, debounceWait = $$props.debounceWait);
    if ('hideEmptyState' in $$props) $$invalidate(19, hideEmptyState = $$props.hideEmptyState);
    if ('inputAttributes' in $$props) $$invalidate(70, inputAttributes = $$props.inputAttributes);
    if ('listAutoWidth' in $$props) $$invalidate(71, listAutoWidth = $$props.listAutoWidth);
    if ('showChevron' in $$props) $$invalidate(20, showChevron = $$props.showChevron);
    if ('listOffset' in $$props) $$invalidate(72, listOffset = $$props.listOffset);
    if ('hoverItemIndex' in $$props) $$invalidate(7, hoverItemIndex = $$props.hoverItemIndex);
    if ('floatingConfig' in $$props) $$invalidate(73, floatingConfig = $$props.floatingConfig);
    if ('class' in $$props) $$invalidate(21, containerClasses = $$props["class"]);
    if ('ariaValues' in $$props) $$invalidate(74, ariaValues = $$props.ariaValues);
    if ('ariaListOpen' in $$props) $$invalidate(75, ariaListOpen = $$props.ariaListOpen);
    if ('ariaFocused' in $$props) $$invalidate(76, ariaFocused = $$props.ariaFocused);
    if ('$$scope' in $$props) $$invalidate(81, $$scope = $$props.$$scope);
  };
  $$self.$$.update = function () {
    if ($$self.$$.dirty[0] & /*value*/8 | $$self.$$.dirty[1] & /*items*/1048576) {
      $: if (items, value) setValue();
    }
    if ($$self.$$.dirty[0] & /*searchable*/131072 | $$self.$$.dirty[2] & /*inputAttributes*/256) {
      $: if (inputAttributes || !searchable) assignInputAttributes();
    }
    if ($$self.$$.dirty[0] & /*multiple*/512) {
      $: if (multiple) setupMulti();
    }
    if ($$self.$$.dirty[0] & /*multiple*/512 | $$self.$$.dirty[2] & /*prev_multiple*/131072) {
      $: if (prev_multiple && !multiple) setupSingle();
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/520) {
      $: if (multiple && value && value.length > 1) checkValueForDuplicates();
    }
    if ($$self.$$.dirty[0] & /*value*/8) {
      $: if (value) dispatchSelectedItem();
    }
    if ($$self.$$.dirty[0] & /*value, multiple*/520 | $$self.$$.dirty[2] & /*prev_value*/32768) {
      $: if (!value && multiple && prev_value) dispatch('input', value);
    }
    if ($$self.$$.dirty[0] & /*focused, input*/6) {
      $: if (!focused && input) closeList();
    }
    if ($$self.$$.dirty[0] & /*filterText*/16 | $$self.$$.dirty[2] & /*prev_filterText*/65536) {
      $: if (filterText !== prev_filterText) setupFilterText();
    }
    if ($$self.$$.dirty[0] & /*filterText, multiple, value, itemId, label*/12824 | $$self.$$.dirty[1] & /*filter, items, groupBy, itemFilter*/407896064 | $$self.$$.dirty[2] & /*loadOptions, filterSelectedItems*/3) {
      $: $$invalidate(24, filteredItems = filter({
        loadOptions: loadOptions,
        filterText: filterText,
        items: items,
        multiple: multiple,
        value: value,
        itemId: itemId,
        groupBy: groupBy,
        label: label,
        filterSelectedItems: filterSelectedItems,
        itemFilter: itemFilter,
        convertStringItemsToObjects: convertStringItemsToObjects,
        filterGroupedItems: filterGroupedItems
      }));
    }
    if ($$self.$$.dirty[0] & /*multiple, listOpen, value, filteredItems*/16777800) {
      $: if (!multiple && listOpen && value && filteredItems) setValueIndexAsHoverIndex();
    }
    if ($$self.$$.dirty[0] & /*listOpen, multiple*/576) {
      $: if (listOpen && multiple) $$invalidate(7, hoverItemIndex = 0);
    }
    if ($$self.$$.dirty[0] & /*filterText*/16) {
      $: if (filterText) $$invalidate(7, hoverItemIndex = 0);
    }
    if ($$self.$$.dirty[0] & /*hoverItemIndex*/128) {
      $: dispatchHover(hoverItemIndex);
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/520) {
      $: $$invalidate(25, hasValue = multiple ? value && value.length > 0 : value);
    }
    if ($$self.$$.dirty[0] & /*hasValue, filterText*/33554448) {
      $: $$invalidate(35, hideSelectedItem = hasValue && filterText.length > 0);
    }
    if ($$self.$$.dirty[0] & /*hasValue, disabled, loading*/33556512 | $$self.$$.dirty[2] & /*clearable*/32) {
      $: $$invalidate(34, showClear = hasValue && clearable && !disabled && !loading);
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/520 | $$self.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/100663296) {
      var _value;
      $: $$invalidate(33, placeholderText = placeholderAlwaysShow && multiple ? placeholder : multiple && ((_value = value) === null || _value === void 0 ? void 0 : _value.length) === 0 ? placeholder : value ? '' : placeholder);
    }
    if ($$self.$$.dirty[0] & /*value, multiple*/520) {
      $: $$invalidate(32, ariaSelection = value ? handleAriaSelection(multiple) : '');
    }
    if ($$self.$$.dirty[0] & /*filteredItems, hoverItemIndex, focused, listOpen*/16777412) {
      $: $$invalidate(31, ariaContext = handleAriaContent({
        filteredItems: filteredItems,
        hoverItemIndex: hoverItemIndex,
        focused: focused,
        listOpen: listOpen
      }));
    }
    if ($$self.$$.dirty[1] & /*items*/1048576) {
      $: updateValueDisplay(items);
    }
    if ($$self.$$.dirty[0] & /*multiple, value, itemId*/8712) {
      $: $$invalidate(52, justValue = computeJustValue(multiple, value, itemId));
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/520 | $$self.$$.dirty[2] & /*prev_value*/32768) {
      $: if (!multiple && prev_value && !value) dispatch('input', value);
    }
    if ($$self.$$.dirty[0] & /*listOpen, filteredItems, multiple, value*/16777800) {
      $: if (listOpen && filteredItems && !multiple && !value) checkHoverSelectable();
    }
    if ($$self.$$.dirty[0] & /*filteredItems*/16777216) {
      $: handleFilterEvent(filteredItems);
    }
    if ($$self.$$.dirty[0] & /*container*/1 | $$self.$$.dirty[2] & /*floatingConfig*/2048) {
      var _floatingConfig2;
      $: if (container && ((_floatingConfig2 = floatingConfig) === null || _floatingConfig2 === void 0 ? void 0 : _floatingConfig2.autoUpdate) === undefined) {
        $$invalidate(80, _floatingConfig.autoUpdate = true, _floatingConfig);
      }
    }
    if ($$self.$$.dirty[0] & /*container*/1 | $$self.$$.dirty[2] & /*floatingConfig, _floatingConfig*/264192) {
      $: if (container && floatingConfig) floatingUpdate(Object.assign(_floatingConfig, floatingConfig));
    }
    if ($$self.$$.dirty[0] & /*list*/8388608) {
      $: $$invalidate(30, listDom = !!list);
    }
    if ($$self.$$.dirty[0] & /*list, listOpen*/8388672) {
      $: listMounted(list, listOpen);
    }
    if ($$self.$$.dirty[0] & /*listOpen, container, list*/8388673) {
      $: if (listOpen && container && list) setListWidth();
    }
    if ($$self.$$.dirty[0] & /*hoverItemIndex*/128) {
      $: $$invalidate(29, scrollToHoverItem = hoverItemIndex);
    }
    if ($$self.$$.dirty[0] & /*input, listOpen, focused*/70) {
      $: if (input && listOpen && !focused) handleFocus();
    }
  };
  return [container, input, focused, value, filterText, loading, listOpen, hoverItemIndex, name, multiple, multiFullItemClearable, disabled, label, itemId, containerStyles, hasError, required, searchable, inputStyles, hideEmptyState, showChevron, containerClasses, handleClear, list, filteredItems, hasValue, activeValue, _inputAttributes, prefloat, scrollToHoverItem, listDom, ariaContext, ariaSelection, placeholderText, showClear, hideSelectedItem, handleMultiItemClear, handleKeyDown, handleFocus, handleBlur, handleClick, handleListScroll, handleClickOutside, handleHover, handleItemClick, isItemActive, activeScroll, hoverScroll, floatingRef, floatingContent, $$slots, items, justValue, filter, getItems, id, placeholder, placeholderAlwaysShow, itemFilter, groupBy, groupFilter, groupHeaderSelectable, loadOptions, filterSelectedItems, closeListOnChange, createGroupHeaderItem, getFilteredItems, clearable, debounce, debounceWait, inputAttributes, listAutoWidth, listOffset, floatingConfig, ariaValues, ariaListOpen, ariaFocused, prev_value, prev_filterText, prev_multiple, _floatingConfig, $$scope, slots, mousedown_handler, keydown_handler_1, pointerup_handler, keydown_handler, mouseover_handler, focus_handler, click_handler, div_binding, pointerup_handler_1, click_handler_1, input_1_binding, input_1_input_handler, div3_binding];
}
var Select = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(Select, _SvelteComponent);
  var _super = _createSuper(Select);
  function Select(options) {
    var _this;
    _classCallCheck(this, Select);
    _this = _super.call(this);
    (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(_assertThisInitialized(_this), options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {
      justValue: 52,
      filter: 53,
      getItems: 54,
      id: 55,
      name: 8,
      container: 0,
      input: 1,
      multiple: 9,
      multiFullItemClearable: 10,
      disabled: 11,
      focused: 2,
      value: 3,
      filterText: 4,
      placeholder: 56,
      placeholderAlwaysShow: 57,
      items: 51,
      label: 12,
      itemFilter: 58,
      groupBy: 59,
      groupFilter: 60,
      groupHeaderSelectable: 61,
      itemId: 13,
      loadOptions: 62,
      containerStyles: 14,
      hasError: 15,
      filterSelectedItems: 63,
      required: 16,
      closeListOnChange: 64,
      createGroupHeaderItem: 65,
      getFilteredItems: 66,
      searchable: 17,
      inputStyles: 18,
      clearable: 67,
      loading: 5,
      listOpen: 6,
      debounce: 68,
      debounceWait: 69,
      hideEmptyState: 19,
      inputAttributes: 70,
      listAutoWidth: 71,
      showChevron: 20,
      listOffset: 72,
      hoverItemIndex: 7,
      floatingConfig: 73,
      "class": 21,
      handleClear: 22,
      ariaValues: 74,
      ariaListOpen: 75,
      ariaFocused: 76
    }, add_css, [-1, -1, -1, -1, -1]);
    return _this;
  }
  _createClass(Select, [{
    key: "getFilteredItems",
    get: function get() {
      return this.$$.ctx[66];
    }
  }, {
    key: "handleClear",
    get: function get() {
      return this.$$.ctx[22];
    }
  }]);
  return Select;
}(svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Select);

/***/ }),

/***/ "./resources/js/components/App.svelte":
/*!********************************************!*\
  !*** ./resources/js/components/App.svelte ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_select__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte-select */ "./node_modules/svelte-select/index.js");
/* harmony import */ var agnostic_svelte_css_common_min_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! agnostic-svelte/css/common.min.css */ "./node_modules/agnostic-svelte/css/common.min.css");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/* resources/js/components/App.svelte generated by Svelte v3.59.1 */




function create_fragment(ctx) {
  var main;
  var div;
  var h1;
  var t1;
  var h2;
  var t3;
  var select;
  var current;
  select = new svelte_select__WEBPACK_IMPORTED_MODULE_2__["default"]({
    props: {
      loadOptions: getCities
    }
  });
  return {
    c: function c() {
      main = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("main");
      div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
      h1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("h1");
      h1.textContent = "Weather";
      t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      h2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("h2");
      h2.textContent = "choose a city";
      t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(select.$$.fragment);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "container");
    },
    m: function m(target, anchor) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, main, anchor);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(main, div);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, h1);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t1);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, h2);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t3);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(select, div, null);
      current = true;
    },
    p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
    i: function i(local) {
      if (current) return;
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(select.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(select.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(main);
      (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(select);
    }
  };
}
function getCities(_x) {
  return _getCities.apply(this, arguments);
}
function _getCities() {
  _getCities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(filterText) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return fetch("/api/cities?q=".concat(filterText));
        case 2:
          return _context.abrupt("return", _context.sent.json());
        case 3:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _getCities.apply(this, arguments);
}
function instance($$self) {
  var updateData = function updateData(val) {
    fetch("/api/weather/".concat(val)).then(function (res) {
      return res.text();
    }).then(function (res) {
      return city = res;
    });
  };
  (0,svelte__WEBPACK_IMPORTED_MODULE_1__.onMount)(function () {}); //

  return [];
}
var App = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(App, _SvelteComponent);
  var _super = _createSuper(App);
  function App(options) {
    var _this;
    _classCallCheck(this, App);
    _this = _super.call(this);
    (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(_assertThisInitialized(_this), options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});
    return _this;
  }
  return _createClass(App);
}(svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_App_svelte__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/App.svelte */ "./resources/js/components/App.svelte");

var app = new _components_App_svelte__WEBPACK_IMPORTED_MODULE_0__["default"]({
  target: document.body
});
window.app = app;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (app);

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[6].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[6].oneOf[1].use[2]!./node_modules/agnostic-svelte/css/common.min.css":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[6].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[6].oneOf[1].use[2]!./node_modules/agnostic-svelte/css/common.min.css ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, ":where(html){--agnostic-warning-border-accent-modelight:#ecd386;--agnostic-warning-border-modelight:#f0e3b9;--agnostic-warning-light-modelight:#fff5d4;--agnostic-warning-dark-modelight:#634902;--agnostic-secondary-hover-modelight:#bc583d;--agnostic-secondary-modelight:#c94d2b;--agnostic-primary-extra-light-modelight:#f1faff;--agnostic-primary-light-modelight:#dcf1ff;--agnostic-primary-dark-modelight:#063f69;--agnostic-primary-border-modelight:#c1d9e9;--agnostic-primary-hover-modelight:#2087d0;--agnostic-primary-modelight:#077acb;--agnostic-light-modelight:#fff;--agnostic-dark-modelight:#333;--agnostic-gray-dark-modelight:#717171;--agnostic-gray-mid-dark-modelight:#ccc;--agnostic-gray-mid-modelight:#d8d8d8;--agnostic-gray-light-modelight:#e9e9e9;--agnostic-gray-extra-light-modelight:#f8f8f8;--agnostic-error-border-modelight:#eec8c8;--agnostic-error-light-modelight:#ffe0e0;--agnostic-error-dark-modelight:#771414;--agnostic-error-modelight:#e02e2e;--agnostic-action-border-modelight:#c7f0d1;--agnostic-action-light-modelight:#e2ffe9;--agnostic-action-dark-modelight:#0a3414;--agnostic-action-hover-modelight:#3dd262;--agnostic-action-modelight:#2fb751;--agnostic-disabled-color-modelight:var(--agnostic-gray-dark-modelight);--agnostic-disabled-bg-modelight:var(--agnostic-gray-light-modelight)}:where(html){--agnostic-warning-border-accent-modedark:#433507;--agnostic-warning-border-modedark:#fff5d4;--agnostic-warning-light-modedark:#faecc0;--agnostic-warning-dark-modedark:#221b01;--agnostic-secondary-hover-modedark:#000;--agnostic-secondary-modedark:#e89982;--agnostic-primary-extra-light-modedark:#172c38;--agnostic-primary-light-modedark:#90d0fd;--agnostic-primary-dark-modedark:#021421;--agnostic-primary-border-modedark:#63b9f7;--agnostic-primary-hover-modedark:#63b9f7;--agnostic-primary-modedark:#91d1ff;--agnostic-light-modedark:#1a202c;--agnostic-dark-modedark:rgb(255 255 255 / 80%);--agnostic-gray-dark-modedark:rgb(255 255 255 / 40%);--agnostic-gray-mid-dark-modedark:rgba(255 255 255 / 32%);--agnostic-gray-mid-modedark:rgba(255 255 255 / 8%);--agnostic-gray-light-modedark:rgba(255 255 255 / 6%);--agnostic-gray-extra-light-modedark:rgba(255 255 255 / 4%);--agnostic-error-border-modedark:#ffe0e0;--agnostic-error-light-modedark:#ffe0e0;--agnostic-error-dark-modedark:#260202;--agnostic-error-modedark:#fd9e9e;--agnostic-action-border-modedark:#e7ffed;--agnostic-action-light-modedark:#baf9ca;--agnostic-action-dark-modedark:#011e08;--agnostic-action-hover-modedark:#9fe0af;--agnostic-action-modedark:#baf9ca;--agnostic-disabled-color-modedark:var(--agnostic-gray-dark-modedark);--agnostic-disabled-bg-modedark:var(--agnostic-gray-light-modedark)}:root{color-scheme:light;--agnostic-warning-border-accent:var(--agnostic-warning-border-accent-modelight);--agnostic-warning-border:var(--agnostic-warning-border-modelight);--agnostic-warning-light:var(--agnostic-warning-light-modelight);--agnostic-warning-dark:var(--agnostic-warning-dark-modelight);--agnostic-secondary-hover:var(--agnostic-secondary-hover-modelight);--agnostic-secondary:var(--agnostic-secondary-modelight);--agnostic-primary-light:var(--agnostic-primary-light-modelight);--agnostic-primary-dark:var(--agnostic-primary-dark-modelight);--agnostic-primary-border:var(--agnostic-primary-border-modelight);--agnostic-primary-hover:var(--agnostic-primary-hover-modelight);--agnostic-primary:var(--agnostic-primary-modelight);--agnostic-light:var(--agnostic-light-modelight);--agnostic-dark:var(--agnostic-dark-modelight);--agnostic-gray-dark:var(--agnostic-gray-dark-modelight);--agnostic-gray-mid-dark:var(--agnostic-gray-mid-dark-modelight);--agnostic-gray-mid:var(--agnostic-gray-mid-modelight);--agnostic-gray-light:var(--agnostic-gray-light-modelight);--agnostic-gray-extra-light:var(--agnostic-gray-extra-light-modelight);--agnostic-error:var(--agnostic-error-modelight);--agnostic-error-light:var(--agnostic-error-light-modelight);--agnostic-error-dark:var(--agnostic-error-dark-modelight);--agnostic-error-border:var(--agnostic-error-border-modelight);--agnostic-disabled-color:var(--agnostic-gray-dark-modelight);--agnostic-disabled-bg:var(--agnostic-gray-light-modelight);--agnostic-action-border:var(--agnostic-action-border-modelight);--agnostic-action-light:var(--agnostic-action-light-modelight);--agnostic-action-dark:var(--agnostic-action-dark-modelight);--agnostic-action-hover:var(--agnostic-action-hover-modelight);--agnostic-action:var(--agnostic-action-modelight)}@media(prefers-color-scheme:dark){:root{color-scheme:dark;--agnostic-warning-border-accent:var(--agnostic-warning-border-accent-modedark);--agnostic-warning-border:var(--agnostic-warning-border-modedark);--agnostic-warning-light:var(--agnostic-warning-light-modedark);--agnostic-warning-dark:var(--agnostic-warning-dark-modedark);--agnostic-secondary-hover:var(--agnostic-secondary-hover-modedark);--agnostic-secondary:var(--agnostic-secondary-modedark);--agnostic-primary-light:var(--agnostic-primary-light-modedark);--agnostic-primary-dark:var(--agnostic-primary-dark-modedark);--agnostic-primary-border:var(--agnostic-primary-border-modedark);--agnostic-primary-hover:var(--agnostic-primary-hover-modedark);--agnostic-primary:var(--agnostic-primary-modedark);--agnostic-light:var(--agnostic-light-modedark);--agnostic-dark:var(--agnostic-dark-modedark);--agnostic-gray-dark:var(--agnostic-gray-dark-modedark);--agnostic-gray-mid-dark:var(--agnostic-gray-mid-dark-modedark);--agnostic-gray-mid:var(--agnostic-gray-mid-modedark);--agnostic-gray-light:var(--agnostic-gray-light-modedark);--agnostic-gray-extra-light:var(--agnostic-gray-extra-light-modedark);--agnostic-error:var(--agnostic-error-modedark);--agnostic-error-light:var(--agnostic-error-light-modedark);--agnostic-error-dark:var(--agnostic-error-dark-modedark);--agnostic-error-border:var(--agnostic-error-border-modedark);--agnostic-disabled-color:var(--agnostic-gray-dark-modedark);--agnostic-disabled-bg:var(--agnostic-gray-light-modedark);--agnostic-action-border:var(--agnostic-action-border-modedark);--agnostic-action-light:var(--agnostic-action-light-modedark);--agnostic-action-dark:var(--agnostic-action-dark-modedark);--agnostic-action-hover:var(--agnostic-action-hover-modedark);--agnostic-action:var(--agnostic-action-modedark)}}[color-scheme=\"light\"]{color-scheme:light;--agnostic-warning-border-accent:var(--agnostic-warning-border-accent-modelight);--agnostic-warning-border:var(--agnostic-warning-border-modelight);--agnostic-warning-light:var(--agnostic-warning-light-modelight);--agnostic-warning-dark:var(--agnostic-warning-dark-modelight);--agnostic-secondary-hover:var(--agnostic-secondary-hover-modelight);--agnostic-secondary:var(--agnostic-secondary-modelight);--agnostic-primary-light:var(--agnostic-primary-light-modelight);--agnostic-primary-dark:var(--agnostic-primary-dark-modelight);--agnostic-primary-border:var(--agnostic-primary-border-modelight);--agnostic-primary-hover:var(--agnostic-primary-hover-modelight);--agnostic-primary:var(--agnostic-primary-modelight);--agnostic-light:var(--agnostic-light-modelight);--agnostic-dark:var(--agnostic-dark-modelight);--agnostic-gray-dark:var(--agnostic-gray-dark-modelight);--agnostic-gray-mid-dark:var(--agnostic-gray-mid-dark-modelight);--agnostic-gray-mid:var(--agnostic-gray-mid-modelight);--agnostic-gray-light:var(--agnostic-gray-light-modelight);--agnostic-gray-extra-light:var(--agnostic-gray-extra-light-modelight);--agnostic-error:var(--agnostic-error-modelight);--agnostic-error-light:var(--agnostic-error-light-modelight);--agnostic-error-dark:var(--agnostic-error-dark-modelight);--agnostic-error-border:var(--agnostic-error-border-modelight);--agnostic-disabled-color:var(--agnostic-gray-dark-modelight);--agnostic-disabled-bg:var(--agnostic-gray-light-modelight);--agnostic-action-border:var(--agnostic-action-border-modelight);--agnostic-action-light:var(--agnostic-action-light-modelight);--agnostic-action-dark:var(--agnostic-action-dark-modelight);--agnostic-action-hover:var(--agnostic-action-hover-modelight);--agnostic-action:var(--agnostic-action-modelight)}[color-scheme=\"dark\"]{color-scheme:dark;--agnostic-warning-border-accent:var(--agnostic-warning-border-accent-modedark);--agnostic-warning-border:var(--agnostic-warning-border-modedark);--agnostic-warning-light:var(--agnostic-warning-light-modedark);--agnostic-warning-dark:var(--agnostic-warning-dark-modedark);--agnostic-secondary-hover:var(--agnostic-secondary-hover-modedark);--agnostic-secondary:var(--agnostic-secondary-modedark);--agnostic-primary-light:var(--agnostic-primary-light-modedark);--agnostic-primary-dark:var(--agnostic-primary-dark-modedark);--agnostic-primary-border:var(--agnostic-primary-border-modedark);--agnostic-primary-hover:var(--agnostic-primary-hover-modedark);--agnostic-primary:var(--agnostic-primary-modedark);--agnostic-light:var(--agnostic-light-modedark);--agnostic-dark:var(--agnostic-dark-modedark);--agnostic-gray-dark:var(--agnostic-gray-dark-modedark);--agnostic-gray-mid-dark:var(--agnostic-gray-mid-dark-modedark);--agnostic-gray-mid:var(--agnostic-gray-mid-modedark);--agnostic-gray-light:var(--agnostic-gray-light-modedark);--agnostic-gray-extra-light:var(--agnostic-gray-extra-light-modedark);--agnostic-error:var(--agnostic-error-modedark);--agnostic-error-light:var(--agnostic-error-light-modedark);--agnostic-error-dark:var(--agnostic-error-dark-modedark);--agnostic-error-border:var(--agnostic-error-border-modedark);--agnostic-disabled-color:var(--agnostic-gray-dark-modedark);--agnostic-disabled-bg:var(--agnostic-gray-light-modedark);--agnostic-action-border:var(--agnostic-action-border-modedark);--agnostic-action-light:var(--agnostic-action-light-modedark);--agnostic-action-dark:var(--agnostic-action-dark-modedark);--agnostic-action-hover:var(--agnostic-action-hover-modedark);--agnostic-action:var(--agnostic-action-modedark)}:where(html){--agnostic-focus-ring-outline-color:transparent;--agnostic-focus-ring-outline-style:solid;--agnostic-focus-ring-outline-width:3px;--agnostic-focus-ring-color:rgb(55 149 225 / 50%)}:where(html){--fluid-80:5rem;--fluid-72:4.5rem;--fluid-64:4rem;--fluid-56:3.5rem;--fluid-48:3rem;--fluid-40:2.5rem;--fluid-36:2.25rem;--fluid-32:2rem;--fluid-24:1.5rem;--fluid-20:1.25rem;--fluid-18:1.125rem;--fluid-16:1rem;--fluid-14:0.875rem;--fluid-12:0.75rem;--fluid-10:0.625rem;--fluid-8:0.5rem;--fluid-6:0.375rem;--fluid-4:0.25rem;--fluid-2:0.125rem;--agnostic-vertical-pad:var(--fluid-8);--agnostic-line-height:var(--fluid-20);--agnostic-side-padding:var(--fluid-12);--agnostic-input-side-padding:var(--fluid-12)}:where(html){--agnostic-small:0.875rem;--agnostic-body:1rem;--agnostic-h6:0.75rem;--agnostic-h5:1.125rem;--agnostic-h4:1.5rem;--agnostic-h3:2.25rem;--agnostic-h2:3rem;--agnostic-h1:4rem;--agnostic-font-color:var(--agnostic-dark);--agnostic-font-weight-bold:600;--agnostic-font-weight-light:300;--agnostic-font-family-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;--agnostic-font-family-serif:Georgia,Cambria,\"Times New Roman\",Times,serif;--agnostic-font-family-body:system-ui,-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Ubuntu,\"Helvetica Neue\",sans-serif}:where(html){--agnostic-timing-slow:450ms;--agnostic-timing-medium:300ms;--agnostic-timing-fast:200ms}:root{--agnostic-radius:var(--fluid-4,0.25rem);--agnostic-radius-capsule:9999px}html{box-sizing:border-box}*,*::before,*::after{box-sizing:inherit}:where(body){line-height:1.5}:where(ul){list-style:none}:where(button,[role=\"button\"]){cursor:pointer}:where(input,button,select,optgroup,textarea){margin:0;font-family:inherit;font-size:inherit;color:inherit;line-height:inherit}:where(table){border-collapse:collapse}:where(th){text-align:-webkit-match-parent;text-align:match-parent;text-align:inherit}:where(thead,tbody,tfoot,tr,td,th){border-color:inherit;border-style:solid;border-width:0}:where(html,body,p,ol,ul,li,dl,dt,dd,blockquote,figure,fieldset,legend,textarea,button,pre,hr,h1,h2,h3,h4,h5,h6){margin:0;padding:0}a{--agnostic-link-color:var(--agnostic-primary,#077acb);color:var(--agnostic-link-color);text-decoration:none}a:hover{text-decoration:underline}a:focus{box-shadow:0 0 0 var(--agnostic-focus-ring-outline-width)var(--agnostic-focus-ring-color);outline:var(--agnostic-focus-ring-outline-width)var(--agnostic-focus-ring-outline-style)var(--agnostic-focus-ring-outline-color);transition:box-shadow var(--agnostic-timing-fast)ease-out}@media(prefers-reduced-motion),(update:slow){a:focus{transition-duration:0.001ms !important}}.screenreader-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.w-100{width:100% !important}.text-lowercase{text-transform:lowercase !important}.text-uppercase{text-transform:uppercase !important}.text-capitalize{text-transform:capitalize !important}.text-center{text-align:center !important}.h1{font-size:var(--agnostic-h1)!important}.h2{font-size:var(--agnostic-h2)!important}.h3{font-size:var(--agnostic-h3)!important}.h4{font-size:var(--agnostic-h4)!important}.h5{font-size:var(--agnostic-h5)!important}.h6{font-size:var(--agnostic-h6)!important}.top{top:0 !important}.bottom{bottom:0 !important}.start{left:var(--fluid-16)!important}.end{right:var(--fluid-16)!important}.center{left:50% !important;transform:translateX(-50%)!important}.flex{display:flex !important}.flex-inline{display:inline-flex !important}.flex-fill{flex:1 1 auto !important}.flex-row{flex-direction:row !important}.flex-column{flex-direction:column !important}.flex-grow-0{flex-grow:0 !important}.flex-grow-1{flex-grow:1 !important}.flex-shrink-0{flex-shrink:0 !important}.flex-shrink-1{flex-shrink:1 !important}.flex-wrap{flex-wrap:wrap !important}.flex-nowrap{flex-wrap:nowrap !important}.items-start{align-items:flex-start !important}.items-end{align-items:flex-end !important}.items-center{align-items:center !important}.items-baseline{align-items:baseline !important}.items-stretch{align-items:stretch !important}.self-start{align-self:flex-start !important}.self-end{align-self:flex-end !important}.self-center{align-self:center !important}.self-baseline{align-self:baseline !important}.self-stretch{align-self:stretch !important}.justify-start{justify-content:flex-start !important}.justify-end{justify-content:flex-end !important}.justify-center{justify-content:center !important}.justify-between{justify-content:space-between !important}.justify-around{justify-content:space-around !important}.content-start{align-content:flex-start !important}.content-end{align-content:flex-end !important}.content-center{align-content:center !important}.content-between{align-content:space-between !important}.content-around{align-content:space-around !important}.content-stretch{align-content:stretch !important}.m0{margin:0 !important}.m2{margin:var(--fluid-2)!important}.m4{margin:var(--fluid-4)!important}.m6{margin:var(--fluid-6)!important}.m8{margin:var(--fluid-8)!important}.m10{margin:var(--fluid-10)!important}.m12{margin:var(--fluid-12)!important}.m14{margin:var(--fluid-14)!important}.m16{margin:var(--fluid-16)!important}.m18{margin:var(--fluid-18)!important}.m20{margin:var(--fluid-20)!important}.m24{margin:var(--fluid-24)!important}.m32{margin:var(--fluid-32)!important}.m36{margin:var(--fluid-36)!important}.m40{margin:var(--fluid-40)!important}.m48{margin:var(--fluid-48)!important}.m56{margin:var(--fluid-56)!important}.m64{margin:var(--fluid-64)!important}.mis0{-webkit-margin-start:0 !important;margin-inline-start:0 !important}.mis2{-webkit-margin-start:var(--fluid-2)!important;margin-inline-start:var(--fluid-2)!important}.mis4{-webkit-margin-start:var(--fluid-4)!important;margin-inline-start:var(--fluid-4)!important}.mis6{-webkit-margin-start:var(--fluid-6)!important;margin-inline-start:var(--fluid-6)!important}.mis8{-webkit-margin-start:var(--fluid-8)!important;margin-inline-start:var(--fluid-8)!important}.mis10{-webkit-margin-start:var(--fluid-10)!important;margin-inline-start:var(--fluid-10)!important}.mis12{-webkit-margin-start:var(--fluid-12)!important;margin-inline-start:var(--fluid-12)!important}.mis14{-webkit-margin-start:var(--fluid-14)!important;margin-inline-start:var(--fluid-14)!important}.mis16{-webkit-margin-start:var(--fluid-16)!important;margin-inline-start:var(--fluid-16)!important}.mis18{-webkit-margin-start:var(--fluid-18)!important;margin-inline-start:var(--fluid-18)!important}.mis20{-webkit-margin-start:var(--fluid-20)!important;margin-inline-start:var(--fluid-20)!important}.mis24{-webkit-margin-start:var(--fluid-24)!important;margin-inline-start:var(--fluid-24)!important}.mis32{-webkit-margin-start:var(--fluid-32)!important;margin-inline-start:var(--fluid-32)!important}.mis36{-webkit-margin-start:var(--fluid-36)!important;margin-inline-start:var(--fluid-36)!important}.mis40{-webkit-margin-start:var(--fluid-40)!important;margin-inline-start:var(--fluid-40)!important}.mis48{-webkit-margin-start:var(--fluid-48)!important;margin-inline-start:var(--fluid-48)!important}.mis56{-webkit-margin-start:var(--fluid-56)!important;margin-inline-start:var(--fluid-56)!important}.mis64{-webkit-margin-start:var(--fluid-64)!important;margin-inline-start:var(--fluid-64)!important}.mie0{-webkit-margin-end:0 !important;margin-inline-end:0 !important}.mie2{-webkit-margin-end:var(--fluid-2)!important;margin-inline-end:var(--fluid-2)!important}.mie4{-webkit-margin-end:var(--fluid-4)!important;margin-inline-end:var(--fluid-4)!important}.mie6{-webkit-margin-end:var(--fluid-6)!important;margin-inline-end:var(--fluid-6)!important}.mie8{-webkit-margin-end:var(--fluid-8)!important;margin-inline-end:var(--fluid-8)!important}.mie10{-webkit-margin-end:var(--fluid-10)!important;margin-inline-end:var(--fluid-10)!important}.mie12{-webkit-margin-end:var(--fluid-12)!important;margin-inline-end:var(--fluid-12)!important}.mie14{-webkit-margin-end:var(--fluid-14)!important;margin-inline-end:var(--fluid-14)!important}.mie16{-webkit-margin-end:var(--fluid-16)!important;margin-inline-end:var(--fluid-16)!important}.mie18{-webkit-margin-end:var(--fluid-18)!important;margin-inline-end:var(--fluid-18)!important}.mie20{-webkit-margin-end:var(--fluid-20)!important;margin-inline-end:var(--fluid-20)!important}.mie24{-webkit-margin-end:var(--fluid-24)!important;margin-inline-end:var(--fluid-24)!important}.mie32{-webkit-margin-end:var(--fluid-32)!important;margin-inline-end:var(--fluid-32)!important}.mie36{-webkit-margin-end:var(--fluid-36)!important;margin-inline-end:var(--fluid-36)!important}.mie40{-webkit-margin-end:var(--fluid-40)!important;margin-inline-end:var(--fluid-40)!important}.mie48{-webkit-margin-end:var(--fluid-48)!important;margin-inline-end:var(--fluid-48)!important}.mie56{-webkit-margin-end:var(--fluid-56)!important;margin-inline-end:var(--fluid-56)!important}.mie64{-webkit-margin-end:var(--fluid-64)!important;margin-inline-end:var(--fluid-64)!important}.mbs0{-webkit-margin-before:0 !important;margin-block-start:0 !important}.mbs2{-webkit-margin-before:var(--fluid-2)!important;margin-block-start:var(--fluid-2)!important}.mbs4{-webkit-margin-before:var(--fluid-4)!important;margin-block-start:var(--fluid-4)!important}.mbs6{-webkit-margin-before:var(--fluid-6)!important;margin-block-start:var(--fluid-6)!important}.mbs8{-webkit-margin-before:var(--fluid-8)!important;margin-block-start:var(--fluid-8)!important}.mbs10{-webkit-margin-before:var(--fluid-10)!important;margin-block-start:var(--fluid-10)!important}.mbs12{-webkit-margin-before:var(--fluid-12)!important;margin-block-start:var(--fluid-12)!important}.mbs14{-webkit-margin-before:var(--fluid-14)!important;margin-block-start:var(--fluid-14)!important}.mbs16{-webkit-margin-before:var(--fluid-16)!important;margin-block-start:var(--fluid-16)!important}.mbs18{-webkit-margin-before:var(--fluid-18)!important;margin-block-start:var(--fluid-18)!important}.mbs20{-webkit-margin-before:var(--fluid-20)!important;margin-block-start:var(--fluid-20)!important}.mbs24{-webkit-margin-before:var(--fluid-24)!important;margin-block-start:var(--fluid-24)!important}.mbs32{-webkit-margin-before:var(--fluid-32)!important;margin-block-start:var(--fluid-32)!important}.mbs36{-webkit-margin-before:var(--fluid-36)!important;margin-block-start:var(--fluid-36)!important}.mbs40{-webkit-margin-before:var(--fluid-40)!important;margin-block-start:var(--fluid-40)!important}.mbs48{-webkit-margin-before:var(--fluid-48)!important;margin-block-start:var(--fluid-48)!important}.mbs56{-webkit-margin-before:var(--fluid-56)!important;margin-block-start:var(--fluid-56)!important}.mbs64{-webkit-margin-before:var(--fluid-64)!important;margin-block-start:var(--fluid-64)!important}.mbe0{-webkit-margin-after:0 !important;margin-block-end:0 !important}.mbe2{-webkit-margin-after:var(--fluid-2)!important;margin-block-end:var(--fluid-2)!important}.mbe4{-webkit-margin-after:var(--fluid-4)!important;margin-block-end:var(--fluid-4)!important}.mbe6{-webkit-margin-after:var(--fluid-6)!important;margin-block-end:var(--fluid-6)!important}.mbe8{-webkit-margin-after:var(--fluid-8)!important;margin-block-end:var(--fluid-8)!important}.mbe10{-webkit-margin-after:var(--fluid-10)!important;margin-block-end:var(--fluid-10)!important}.mbe12{-webkit-margin-after:var(--fluid-12)!important;margin-block-end:var(--fluid-12)!important}.mbe14{-webkit-margin-after:var(--fluid-14)!important;margin-block-end:var(--fluid-14)!important}.mbe16{-webkit-margin-after:var(--fluid-16)!important;margin-block-end:var(--fluid-16)!important}.mbe18{-webkit-margin-after:var(--fluid-18)!important;margin-block-end:var(--fluid-18)!important}.mbe20{-webkit-margin-after:var(--fluid-20)!important;margin-block-end:var(--fluid-20)!important}.mbe24{-webkit-margin-after:var(--fluid-24)!important;margin-block-end:var(--fluid-24)!important}.mbe32{-webkit-margin-after:var(--fluid-32)!important;margin-block-end:var(--fluid-32)!important}.mbe36{-webkit-margin-after:var(--fluid-36)!important;margin-block-end:var(--fluid-36)!important}.mbe40{-webkit-margin-after:var(--fluid-40)!important;margin-block-end:var(--fluid-40)!important}.mbe48{-webkit-margin-after:var(--fluid-48)!important;margin-block-end:var(--fluid-48)!important}.mbe56{-webkit-margin-after:var(--fluid-56)!important;margin-block-end:var(--fluid-56)!important}.mbe64{-webkit-margin-after:var(--fluid-64)!important;margin-block-end:var(--fluid-64)!important}.p0{padding:0 !important}.p2{padding:var(--fluid-2)!important}.p4{padding:var(--fluid-4)!important}.p6{padding:var(--fluid-6)!important}.p8{padding:var(--fluid-8)!important}.p10{padding:var(--fluid-10)!important}.p12{padding:var(--fluid-12)!important}.p14{padding:var(--fluid-14)!important}.p16{padding:var(--fluid-16)!important}.p18{padding:var(--fluid-18)!important}.p20{padding:var(--fluid-20)!important}.p24{padding:var(--fluid-24)!important}.p32{padding:var(--fluid-32)!important}.p36{padding:var(--fluid-36)!important}.p40{padding:var(--fluid-40)!important}.p48{padding:var(--fluid-48)!important}.p56{padding:var(--fluid-56)!important}.p64{padding:var(--fluid-64)!important}.pis0{-webkit-padding-start:0 !important;padding-inline-start:0 !important}.pis2{-webkit-padding-start:var(--fluid-2)!important;padding-inline-start:var(--fluid-2)!important}.pis4{-webkit-padding-start:var(--fluid-4)!important;padding-inline-start:var(--fluid-4)!important}.pis6{-webkit-padding-start:var(--fluid-6)!important;padding-inline-start:var(--fluid-6)!important}.pis8{-webkit-padding-start:var(--fluid-8)!important;padding-inline-start:var(--fluid-8)!important}.pis10{-webkit-padding-start:var(--fluid-10)!important;padding-inline-start:var(--fluid-10)!important}.pis12{-webkit-padding-start:var(--fluid-12)!important;padding-inline-start:var(--fluid-12)!important}.pis14{-webkit-padding-start:var(--fluid-14)!important;padding-inline-start:var(--fluid-14)!important}.pis16{-webkit-padding-start:var(--fluid-16)!important;padding-inline-start:var(--fluid-16)!important}.pis18{-webkit-padding-start:var(--fluid-18)!important;padding-inline-start:var(--fluid-18)!important}.pis20{-webkit-padding-start:var(--fluid-20)!important;padding-inline-start:var(--fluid-20)!important}.pis24{-webkit-padding-start:var(--fluid-24)!important;padding-inline-start:var(--fluid-24)!important}.pis32{-webkit-padding-start:var(--fluid-32)!important;padding-inline-start:var(--fluid-32)!important}.pis36{-webkit-padding-start:var(--fluid-36)!important;padding-inline-start:var(--fluid-36)!important}.pis40{-webkit-padding-start:var(--fluid-40)!important;padding-inline-start:var(--fluid-40)!important}.pis48{-webkit-padding-start:var(--fluid-48)!important;padding-inline-start:var(--fluid-48)!important}.pis56{-webkit-padding-start:var(--fluid-56)!important;padding-inline-start:var(--fluid-56)!important}.pis64{-webkit-padding-start:var(--fluid-64)!important;padding-inline-start:var(--fluid-64)!important}.pie0{-webkit-padding-end:0 !important;padding-inline-end:0 !important}.pie2{-webkit-padding-end:var(--fluid-2)!important;padding-inline-end:var(--fluid-2)!important}.pie4{-webkit-padding-end:var(--fluid-4)!important;padding-inline-end:var(--fluid-4)!important}.pie6{-webkit-padding-end:var(--fluid-6)!important;padding-inline-end:var(--fluid-6)!important}.pie8{-webkit-padding-end:var(--fluid-8)!important;padding-inline-end:var(--fluid-8)!important}.pie10{-webkit-padding-end:var(--fluid-10)!important;padding-inline-end:var(--fluid-10)!important}.pie12{-webkit-padding-end:var(--fluid-12)!important;padding-inline-end:var(--fluid-12)!important}.pie14{-webkit-padding-end:var(--fluid-14)!important;padding-inline-end:var(--fluid-14)!important}.pie16{-webkit-padding-end:var(--fluid-16)!important;padding-inline-end:var(--fluid-16)!important}.pie18{-webkit-padding-end:var(--fluid-18)!important;padding-inline-end:var(--fluid-18)!important}.pie20{-webkit-padding-end:var(--fluid-20)!important;padding-inline-end:var(--fluid-20)!important}.pie24{-webkit-padding-end:var(--fluid-24)!important;padding-inline-end:var(--fluid-24)!important}.pie32{-webkit-padding-end:var(--fluid-32)!important;padding-inline-end:var(--fluid-32)!important}.pie36{-webkit-padding-end:var(--fluid-36)!important;padding-inline-end:var(--fluid-36)!important}.pie40{-webkit-padding-end:var(--fluid-40)!important;padding-inline-end:var(--fluid-40)!important}.pie48{-webkit-padding-end:var(--fluid-48)!important;padding-inline-end:var(--fluid-48)!important}.pie56{-webkit-padding-end:var(--fluid-56)!important;padding-inline-end:var(--fluid-56)!important}.pie64{-webkit-padding-end:var(--fluid-64)!important;padding-inline-end:var(--fluid-64)!important}.pbs0{-webkit-padding-before:0 !important;padding-block-start:0 !important}.pbs2{-webkit-padding-before:var(--fluid-2)!important;padding-block-start:var(--fluid-2)!important}.pbs4{-webkit-padding-before:var(--fluid-4)!important;padding-block-start:var(--fluid-4)!important}.pbs6{-webkit-padding-before:var(--fluid-6)!important;padding-block-start:var(--fluid-6)!important}.pbs8{-webkit-padding-before:var(--fluid-8)!important;padding-block-start:var(--fluid-8)!important}.pbs10{-webkit-padding-before:var(--fluid-10)!important;padding-block-start:var(--fluid-10)!important}.pbs12{-webkit-padding-before:var(--fluid-12)!important;padding-block-start:var(--fluid-12)!important}.pbs14{-webkit-padding-before:var(--fluid-14)!important;padding-block-start:var(--fluid-14)!important}.pbs16{-webkit-padding-before:var(--fluid-16)!important;padding-block-start:var(--fluid-16)!important}.pbs18{-webkit-padding-before:var(--fluid-18)!important;padding-block-start:var(--fluid-18)!important}.pbs20{-webkit-padding-before:var(--fluid-20)!important;padding-block-start:var(--fluid-20)!important}.pbs24{-webkit-padding-before:var(--fluid-24)!important;padding-block-start:var(--fluid-24)!important}.pbs32{-webkit-padding-before:var(--fluid-32)!important;padding-block-start:var(--fluid-32)!important}.pbs36{-webkit-padding-before:var(--fluid-36)!important;padding-block-start:var(--fluid-36)!important}.pbs40{-webkit-padding-before:var(--fluid-40)!important;padding-block-start:var(--fluid-40)!important}.pbs48{-webkit-padding-before:var(--fluid-48)!important;padding-block-start:var(--fluid-48)!important}.pbs56{-webkit-padding-before:var(--fluid-56)!important;padding-block-start:var(--fluid-56)!important}.pbs64{-webkit-padding-before:var(--fluid-64)!important;padding-block-start:var(--fluid-64)!important}.pbe0{-webkit-padding-after:0 !important;padding-block-end:0 !important}.pbe2{-webkit-padding-after:var(--fluid-2)!important;padding-block-end:var(--fluid-2)!important}.pbe4{-webkit-padding-after:var(--fluid-4)!important;padding-block-end:var(--fluid-4)!important}.pbe6{-webkit-padding-after:var(--fluid-6)!important;padding-block-end:var(--fluid-6)!important}.pbe8{-webkit-padding-after:var(--fluid-8)!important;padding-block-end:var(--fluid-8)!important}.pbe10{-webkit-padding-after:var(--fluid-10)!important;padding-block-end:var(--fluid-10)!important}.pbe12{-webkit-padding-after:var(--fluid-12)!important;padding-block-end:var(--fluid-12)!important}.pbe14{-webkit-padding-after:var(--fluid-14)!important;padding-block-end:var(--fluid-14)!important}.pbe16{-webkit-padding-after:var(--fluid-16)!important;padding-block-end:var(--fluid-16)!important}.pbe18{-webkit-padding-after:var(--fluid-18)!important;padding-block-end:var(--fluid-18)!important}.pbe20{-webkit-padding-after:var(--fluid-20)!important;padding-block-end:var(--fluid-20)!important}.pbe24{-webkit-padding-after:var(--fluid-24)!important;padding-block-end:var(--fluid-24)!important}.pbe32{-webkit-padding-after:var(--fluid-32)!important;padding-block-end:var(--fluid-32)!important}.pbe36{-webkit-padding-after:var(--fluid-36)!important;padding-block-end:var(--fluid-36)!important}.pbe40{-webkit-padding-after:var(--fluid-40)!important;padding-block-end:var(--fluid-40)!important}.pbe48{-webkit-padding-after:var(--fluid-48)!important;padding-block-end:var(--fluid-48)!important}.pbe56{-webkit-padding-after:var(--fluid-56)!important;padding-block-end:var(--fluid-56)!important}.pbe64{-webkit-padding-after:var(--fluid-64)!important;padding-block-end:var(--fluid-64)!important}", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./resources/css/app.css":
/*!*******************************!*\
  !*** ./resources/css/app.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/agnostic-svelte/css/common.min.css":
/*!*********************************************************!*\
  !*** ./node_modules/agnostic-svelte/css/common.min.css ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_ruleSet_1_rules_6_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_6_oneOf_1_use_2_common_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js??ruleSet[1].rules[6].oneOf[1].use[1]!../../postcss-loader/dist/cjs.js??ruleSet[1].rules[6].oneOf[1].use[2]!./common.min.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[6].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[6].oneOf[1].use[2]!./node_modules/agnostic-svelte/css/common.min.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ruleSet_1_rules_6_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_6_oneOf_1_use_2_common_min_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ruleSet_1_rules_6_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_6_oneOf_1_use_2_common_min_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* binding */ arrow),
/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),
/* harmony export */   computePosition: () => (/* binding */ computePosition),
/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),
/* harmony export */   flip: () => (/* binding */ flip),
/* harmony export */   hide: () => (/* binding */ hide),
/* harmony export */   inline: () => (/* binding */ inline),
/* harmony export */   limitShift: () => (/* binding */ limitShift),
/* harmony export */   offset: () => (/* binding */ offset),
/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),
/* harmony export */   shift: () => (/* binding */ shift),
/* harmony export */   size: () => (/* binding */ size)
/* harmony export */ });
var _excluded = ["crossAxis", "alignment", "allowedPlacements", "autoAlignment"],
  _excluded2 = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"],
  _excluded3 = ["strategy"],
  _excluded4 = ["mainAxis", "crossAxis", "limiter"],
  _excluded5 = ["apply"];
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  var reference = _ref.reference,
    floating = _ref.floating;
  var commonX = reference.x + reference.width / 2 - floating.width / 2;
  var commonY = reference.y + reference.height / 2 - floating.height / 2;
  var mainAxis = getMainAxisFromPlacement(placement);
  var length = getLengthFromAxis(mainAxis);
  var commonAlign = reference[length] / 2 - floating[length] / 2;
  var side = getSide(placement);
  var isVertical = mainAxis === 'x';
  var coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
var computePosition = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(reference, floating, config) {
    var _config$placement, placement, _config$strategy, strategy, _config$middleware, middleware, platform, validMiddleware, rtl, rects, _computeCoordsFromPla, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware$i, name, fn, _yield$fn, nextX, nextY, data, reset, _computeCoordsFromPla2;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _config$placement = config.placement, placement = _config$placement === void 0 ? 'bottom' : _config$placement, _config$strategy = config.strategy, strategy = _config$strategy === void 0 ? 'absolute' : _config$strategy, _config$middleware = config.middleware, middleware = _config$middleware === void 0 ? [] : _config$middleware, platform = config.platform;
          validMiddleware = middleware.filter(Boolean);
          _context.next = 4;
          return platform.isRTL == null ? void 0 : platform.isRTL(floating);
        case 4:
          rtl = _context.sent;
          _context.next = 7;
          return platform.getElementRects({
            reference: reference,
            floating: floating,
            strategy: strategy
          });
        case 7:
          rects = _context.sent;
          _computeCoordsFromPla = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPla.x, y = _computeCoordsFromPla.y;
          statefulPlacement = placement;
          middlewareData = {};
          resetCount = 0;
          i = 0;
        case 13:
          if (!(i < validMiddleware.length)) {
            _context.next = 46;
            break;
          }
          _validMiddleware$i = validMiddleware[i], name = _validMiddleware$i.name, fn = _validMiddleware$i.fn;
          _context.next = 17;
          return fn({
            x: x,
            y: y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy: strategy,
            middlewareData: middlewareData,
            rects: rects,
            platform: platform,
            elements: {
              reference: reference,
              floating: floating
            }
          });
        case 17:
          _yield$fn = _context.sent;
          nextX = _yield$fn.x;
          nextY = _yield$fn.y;
          data = _yield$fn.data;
          reset = _yield$fn.reset;
          x = nextX != null ? nextX : x;
          y = nextY != null ? nextY : y;
          middlewareData = _objectSpread(_objectSpread({}, middlewareData), {}, _defineProperty({}, name, _objectSpread(_objectSpread({}, middlewareData[name]), data)));
          if (!(reset && resetCount <= 50)) {
            _context.next = 43;
            break;
          }
          resetCount++;
          if (!(_typeof(reset) === 'object')) {
            _context.next = 41;
            break;
          }
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (!reset.rects) {
            _context.next = 38;
            break;
          }
          if (!(reset.rects === true)) {
            _context.next = 36;
            break;
          }
          _context.next = 33;
          return platform.getElementRects({
            reference: reference,
            floating: floating,
            strategy: strategy
          });
        case 33:
          _context.t0 = _context.sent;
          _context.next = 37;
          break;
        case 36:
          _context.t0 = reset.rects;
        case 37:
          rects = _context.t0;
        case 38:
          _computeCoordsFromPla2 = computeCoordsFromPlacement(rects, statefulPlacement, rtl);
          x = _computeCoordsFromPla2.x;
          y = _computeCoordsFromPla2.y;
        case 41:
          i = -1;
          return _context.abrupt("continue", 43);
        case 43:
          i++;
          _context.next = 13;
          break;
        case 46:
          return _context.abrupt("return", {
            x: x,
            y: y,
            placement: statefulPlacement,
            strategy: strategy,
            middlewareData: middlewareData
          });
        case 47:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function computePosition(_x, _x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();
function expandPaddingObject(padding) {
  return _objectSpread({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return _objectSpread(_objectSpread({}, rect), {}, {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
function detectOverflow(_x4, _x5) {
  return _detectOverflow.apply(this, arguments);
}
function _detectOverflow() {
  _detectOverflow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(state, options) {
    var _await$platform$isEle, x, y, platform, rects, elements, strategy, _options8, _options8$boundary, boundary, _options8$rootBoundar, rootBoundary, _options8$elementCont, elementContext, _options8$altBoundary, altBoundary, _options8$padding, padding, paddingObject, altContext, element, clippingClientRect, rect, offsetParent, offsetScale, elementClientRect;
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          if (options === void 0) {
            options = {};
          }
          x = state.x, y = state.y, platform = state.platform, rects = state.rects, elements = state.elements, strategy = state.strategy;
          _options8 = options, _options8$boundary = _options8.boundary, boundary = _options8$boundary === void 0 ? 'clippingAncestors' : _options8$boundary, _options8$rootBoundar = _options8.rootBoundary, rootBoundary = _options8$rootBoundar === void 0 ? 'viewport' : _options8$rootBoundar, _options8$elementCont = _options8.elementContext, elementContext = _options8$elementCont === void 0 ? 'floating' : _options8$elementCont, _options8$altBoundary = _options8.altBoundary, altBoundary = _options8$altBoundary === void 0 ? false : _options8$altBoundary, _options8$padding = _options8.padding, padding = _options8$padding === void 0 ? 0 : _options8$padding;
          paddingObject = getSideObjectFromPadding(padding);
          altContext = elementContext === 'floating' ? 'reference' : 'floating';
          element = elements[altBoundary ? altContext : elementContext];
          _context10.t0 = rectToClientRect;
          _context10.t1 = platform;
          _context10.next = 10;
          return platform.isElement == null ? void 0 : platform.isElement(element);
        case 10:
          _context10.t2 = _await$platform$isEle = _context10.sent;
          if (!(_context10.t2 != null)) {
            _context10.next = 15;
            break;
          }
          _context10.t3 = _await$platform$isEle;
          _context10.next = 16;
          break;
        case 15:
          _context10.t3 = true;
        case 16:
          if (!_context10.t3) {
            _context10.next = 20;
            break;
          }
          _context10.t4 = element;
          _context10.next = 26;
          break;
        case 20:
          _context10.t5 = element.contextElement;
          if (_context10.t5) {
            _context10.next = 25;
            break;
          }
          _context10.next = 24;
          return platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating);
        case 24:
          _context10.t5 = _context10.sent;
        case 25:
          _context10.t4 = _context10.t5;
        case 26:
          _context10.t6 = _context10.t4;
          _context10.t7 = boundary;
          _context10.t8 = rootBoundary;
          _context10.t9 = strategy;
          _context10.t10 = {
            element: _context10.t6,
            boundary: _context10.t7,
            rootBoundary: _context10.t8,
            strategy: _context10.t9
          };
          _context10.next = 33;
          return _context10.t1.getClippingRect.call(_context10.t1, _context10.t10);
        case 33:
          _context10.t11 = _context10.sent;
          clippingClientRect = (0, _context10.t0)(_context10.t11);
          rect = elementContext === 'floating' ? _objectSpread(_objectSpread({}, rects.floating), {}, {
            x: x,
            y: y
          }) : rects.reference;
          _context10.next = 38;
          return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating);
        case 38:
          offsetParent = _context10.sent;
          _context10.next = 41;
          return platform.isElement == null ? void 0 : platform.isElement(offsetParent);
        case 41:
          if (!_context10.sent) {
            _context10.next = 50;
            break;
          }
          _context10.next = 44;
          return platform.getScale == null ? void 0 : platform.getScale(offsetParent);
        case 44:
          _context10.t13 = _context10.sent;
          if (_context10.t13) {
            _context10.next = 47;
            break;
          }
          _context10.t13 = {
            x: 1,
            y: 1
          };
        case 47:
          _context10.t12 = _context10.t13;
          _context10.next = 51;
          break;
        case 50:
          _context10.t12 = {
            x: 1,
            y: 1
          };
        case 51:
          offsetScale = _context10.t12;
          _context10.t14 = rectToClientRect;
          if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) {
            _context10.next = 59;
            break;
          }
          _context10.next = 56;
          return platform.convertOffsetParentRelativeRectToViewportRelativeRect({
            rect: rect,
            offsetParent: offsetParent,
            strategy: strategy
          });
        case 56:
          _context10.t15 = _context10.sent;
          _context10.next = 60;
          break;
        case 59:
          _context10.t15 = rect;
        case 60:
          _context10.t16 = _context10.t15;
          elementClientRect = (0, _context10.t14)(_context10.t16);
          return _context10.abrupt("return", {
            top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
            bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
            left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
            right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
          });
        case 63:
        case "end":
          return _context10.stop();
      }
    }, _callee10);
  }));
  return _detectOverflow.apply(this, arguments);
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
var arrow = function arrow(options) {
  return {
    name: 'arrow',
    options: options,
    fn: function fn(state) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _data, _ref4;
        var _ref3, element, _ref3$padding, padding, x, y, placement, rects, platform, elements, paddingObject, coords, axis, length, arrowDimensions, isYAxis, minProp, maxProp, clientProp, endDiff, startDiff, arrowOffsetParent, clientSize, centerToReference, min, max, center, offset, shouldAddOffset, alignmentOffset;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              // Since `element` is required, we don't Partial<> the type.
              _ref3 = options || {}, element = _ref3.element, _ref3$padding = _ref3.padding, padding = _ref3$padding === void 0 ? 0 : _ref3$padding;
              x = state.x, y = state.y, placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements;
              if (!(element == null)) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("return", {});
            case 4:
              paddingObject = getSideObjectFromPadding(padding);
              coords = {
                x: x,
                y: y
              };
              axis = getMainAxisFromPlacement(placement);
              length = getLengthFromAxis(axis);
              _context2.next = 10;
              return platform.getDimensions(element);
            case 10:
              arrowDimensions = _context2.sent;
              isYAxis = axis === 'y';
              minProp = isYAxis ? 'top' : 'left';
              maxProp = isYAxis ? 'bottom' : 'right';
              clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
              endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
              startDiff = coords[axis] - rects.reference[axis];
              _context2.next = 19;
              return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element);
            case 19:
              arrowOffsetParent = _context2.sent;
              clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0; // DOM platform can return `window` as the `offsetParent`.
              _context2.t0 = !clientSize;
              if (_context2.t0) {
                _context2.next = 26;
                break;
              }
              _context2.next = 25;
              return platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent);
            case 25:
              _context2.t0 = !_context2.sent;
            case 26:
              if (!_context2.t0) {
                _context2.next = 28;
                break;
              }
              clientSize = elements.floating[clientProp] || rects.floating[length];
            case 28:
              centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center
              // point is outside the floating element's bounds.
              min = paddingObject[minProp];
              max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
              center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
              offset = within(min, center, max); // If the reference is small enough that the arrow's padding causes it to
              // to point to nothing for an aligned placement, adjust the offset of the
              // floating element itself. This stops `shift()` from taking action, but can
              // be worked around by calling it again after the `arrow()` if desired.
              shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
              alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;
              return _context2.abrupt("return", (_ref4 = {}, _defineProperty(_ref4, axis, coords[axis] - alignmentOffset), _defineProperty(_ref4, "data", (_data = {}, _defineProperty(_data, axis, offset), _defineProperty(_data, "centerOffset", center - offset), _data)), _ref4));
            case 36:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    }
  };
};
var sides = ['top', 'right', 'bottom', 'left'];
var allPlacements = /*#__PURE__*/sides.reduce(function (acc, side) {
  return acc.concat(side, side + "-start", side + "-end");
}, []);
var oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (side) {
    return oppositeSideMap[side];
  });
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  var alignment = getAlignment(placement);
  var mainAxis = getMainAxisFromPlacement(placement);
  var length = getLengthFromAxis(mainAxis);
  var mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, function (alignment) {
    return oppositeAlignmentMap[alignment];
  });
}
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  var allowedPlacementsSortedByAlignment = alignment ? [].concat(_toConsumableArray(allowedPlacements.filter(function (placement) {
    return getAlignment(placement) === alignment;
  })), _toConsumableArray(allowedPlacements.filter(function (placement) {
    return getAlignment(placement) !== alignment;
  }))) : allowedPlacements.filter(function (placement) {
    return getSide(placement) === placement;
  });
  return allowedPlacementsSortedByAlignment.filter(function (placement) {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
var autoPlacement = function autoPlacement(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options: options,
    fn: function fn(state) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE, rects, middlewareData, placement, platform, elements, _options, _options$crossAxis, crossAxis, alignment, _options$allowedPlace, allowedPlacements, _options$autoAlignmen, autoAlignment, detectOverflowOptions, placements, overflow, currentIndex, currentPlacement, _getAlignmentSides, main, cross, currentOverflows, allOverflows, nextPlacement, placementsSortedByMostSpace, placementsThatFitOnEachSide, resetPlacement;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              rects = state.rects, middlewareData = state.middlewareData, placement = state.placement, platform = state.platform, elements = state.elements;
              _options = options, _options$crossAxis = _options.crossAxis, crossAxis = _options$crossAxis === void 0 ? false : _options$crossAxis, alignment = _options.alignment, _options$allowedPlace = _options.allowedPlacements, allowedPlacements = _options$allowedPlace === void 0 ? allPlacements : _options$allowedPlace, _options$autoAlignmen = _options.autoAlignment, autoAlignment = _options$autoAlignmen === void 0 ? true : _options$autoAlignmen, detectOverflowOptions = _objectWithoutProperties(_options, _excluded);
              placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
              _context3.next = 5;
              return detectOverflow(state, detectOverflowOptions);
            case 5:
              overflow = _context3.sent;
              currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
              currentPlacement = placements[currentIndex];
              if (!(currentPlacement == null)) {
                _context3.next = 10;
                break;
              }
              return _context3.abrupt("return", {});
            case 10:
              _context3.t0 = getAlignmentSides;
              _context3.t1 = currentPlacement;
              _context3.t2 = rects;
              _context3.next = 15;
              return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);
            case 15:
              _context3.t3 = _context3.sent;
              _getAlignmentSides = (0, _context3.t0)(_context3.t1, _context3.t2, _context3.t3);
              main = _getAlignmentSides.main;
              cross = _getAlignmentSides.cross;
              if (!(placement !== currentPlacement)) {
                _context3.next = 21;
                break;
              }
              return _context3.abrupt("return", {
                reset: {
                  placement: placements[0]
                }
              });
            case 21:
              currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];
              allOverflows = [].concat(_toConsumableArray(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), [{
                placement: currentPlacement,
                overflows: currentOverflows
              }]);
              nextPlacement = placements[currentIndex + 1]; // There are more placements to check.
              if (!nextPlacement) {
                _context3.next = 26;
                break;
              }
              return _context3.abrupt("return", {
                data: {
                  index: currentIndex + 1,
                  overflows: allOverflows
                },
                reset: {
                  placement: nextPlacement
                }
              });
            case 26:
              placementsSortedByMostSpace = allOverflows.map(function (d) {
                var alignment = getAlignment(d.placement);
                return [d.placement, alignment && crossAxis ?
                // Check along the mainAxis and main crossAxis side.
                d.overflows.slice(0, 2).reduce(function (acc, v) {
                  return acc + v;
                }, 0) :
                // Check only the mainAxis.
                d.overflows[0], d.overflows];
              }).sort(function (a, b) {
                return a[1] - b[1];
              });
              placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(function (d) {
                return d[2].slice(0,
                // Aligned placements should not check their opposite crossAxis
                // side.
                getAlignment(d[0]) ? 2 : 3).every(function (v) {
                  return v <= 0;
                });
              });
              resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
              if (!(resetPlacement !== placement)) {
                _context3.next = 31;
                break;
              }
              return _context3.abrupt("return", {
                data: {
                  index: currentIndex + 1,
                  overflows: allOverflows
                },
                reset: {
                  placement: resetPlacement
                }
              });
            case 31:
              return _context3.abrupt("return", {});
            case 32:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
  };
};
function getExpandedPlacements(placement) {
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getSideList(side, isStart, rtl) {
  var lr = ['left', 'right'];
  var rl = ['right', 'left'];
  var tb = ['top', 'bottom'];
  var bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  var alignment = getAlignment(placement);
  var list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(function (side) {
      return side + "-" + alignment;
    });
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
var flip = function flip(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options: options,
    fn: function fn(state) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform, elements, _options2, _options2$mainAxis, checkMainAxis, _options2$crossAxis, checkCrossAxis, specifiedFallbackPlacements, _options2$fallbackStr, fallbackStrategy, _options2$fallbackAxi, fallbackAxisSideDirection, _options2$flipAlignme, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, placements, overflow, overflows, overflowsData, _getAlignmentSides2, main, cross, _middlewareData$flip2, _overflowsData$filter, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, _placement;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              placement = state.placement, middlewareData = state.middlewareData, rects = state.rects, initialPlacement = state.initialPlacement, platform = state.platform, elements = state.elements;
              _options2 = options, _options2$mainAxis = _options2.mainAxis, checkMainAxis = _options2$mainAxis === void 0 ? true : _options2$mainAxis, _options2$crossAxis = _options2.crossAxis, checkCrossAxis = _options2$crossAxis === void 0 ? true : _options2$crossAxis, specifiedFallbackPlacements = _options2.fallbackPlacements, _options2$fallbackStr = _options2.fallbackStrategy, fallbackStrategy = _options2$fallbackStr === void 0 ? 'bestFit' : _options2$fallbackStr, _options2$fallbackAxi = _options2.fallbackAxisSideDirection, fallbackAxisSideDirection = _options2$fallbackAxi === void 0 ? 'none' : _options2$fallbackAxi, _options2$flipAlignme = _options2.flipAlignment, flipAlignment = _options2$flipAlignme === void 0 ? true : _options2$flipAlignme, detectOverflowOptions = _objectWithoutProperties(_options2, _excluded2);
              side = getSide(placement);
              isBasePlacement = getSide(initialPlacement) === initialPlacement;
              _context4.next = 6;
              return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);
            case 6:
              rtl = _context4.sent;
              fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
              if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
                fallbackPlacements.push.apply(fallbackPlacements, _toConsumableArray(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));
              }
              placements = [initialPlacement].concat(_toConsumableArray(fallbackPlacements));
              _context4.next = 12;
              return detectOverflow(state, detectOverflowOptions);
            case 12:
              overflow = _context4.sent;
              overflows = [];
              overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
              if (checkMainAxis) {
                overflows.push(overflow[side]);
              }
              if (checkCrossAxis) {
                _getAlignmentSides2 = getAlignmentSides(placement, rects, rtl), main = _getAlignmentSides2.main, cross = _getAlignmentSides2.cross;
                overflows.push(overflow[main], overflow[cross]);
              }
              overflowsData = [].concat(_toConsumableArray(overflowsData), [{
                placement: placement,
                overflows: overflows
              }]);

              // One or more sides is overflowing.
              if (overflows.every(function (side) {
                return side <= 0;
              })) {
                _context4.next = 35;
                break;
              }
              nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
              nextPlacement = placements[nextIndex];
              if (!nextPlacement) {
                _context4.next = 23;
                break;
              }
              return _context4.abrupt("return", {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              });
            case 23:
              // First, find the candidates that fit on the mainAxis side of overflow,
              // then find the placement that fits the best on the main crossAxis side.
              resetPlacement = (_overflowsData$filter = overflowsData.filter(function (d) {
                return d.overflows[0] <= 0;
              }).sort(function (a, b) {
                return a.overflows[1] - b.overflows[1];
              })[0]) == null ? void 0 : _overflowsData$filter.placement; // Otherwise fallback.
              if (resetPlacement) {
                _context4.next = 33;
                break;
              }
              _context4.t0 = fallbackStrategy;
              _context4.next = _context4.t0 === 'bestFit' ? 28 : _context4.t0 === 'initialPlacement' ? 31 : 33;
              break;
            case 28:
              _placement = (_overflowsData$map$so = overflowsData.map(function (d) {
                return [d.placement, d.overflows.filter(function (overflow) {
                  return overflow > 0;
                }).reduce(function (acc, overflow) {
                  return acc + overflow;
                }, 0)];
              }).sort(function (a, b) {
                return a[1] - b[1];
              })[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (_placement) {
                resetPlacement = _placement;
              }
              return _context4.abrupt("break", 33);
            case 31:
              resetPlacement = initialPlacement;
              return _context4.abrupt("break", 33);
            case 33:
              if (!(placement !== resetPlacement)) {
                _context4.next = 35;
                break;
              }
              return _context4.abrupt("return", {
                reset: {
                  placement: resetPlacement
                }
              });
            case 35:
              return _context4.abrupt("return", {});
            case 36:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }))();
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(function (side) {
    return overflow[side] >= 0;
  });
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
var hide = function hide(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options: options,
    fn: function fn(state) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _options3, _options3$strategy, strategy, detectOverflowOptions, rects, overflow, offsets, _overflow, _offsets;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _options3 = options, _options3$strategy = _options3.strategy, strategy = _options3$strategy === void 0 ? 'referenceHidden' : _options3$strategy, detectOverflowOptions = _objectWithoutProperties(_options3, _excluded3);
              rects = state.rects;
              _context5.t0 = strategy;
              _context5.next = _context5.t0 === 'referenceHidden' ? 5 : _context5.t0 === 'escaped' ? 10 : 15;
              break;
            case 5:
              _context5.next = 7;
              return detectOverflow(state, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {
                elementContext: 'reference'
              }));
            case 7:
              overflow = _context5.sent;
              offsets = getSideOffsets(overflow, rects.reference);
              return _context5.abrupt("return", {
                data: {
                  referenceHiddenOffsets: offsets,
                  referenceHidden: isAnySideFullyClipped(offsets)
                }
              });
            case 10:
              _context5.next = 12;
              return detectOverflow(state, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {
                altBoundary: true
              }));
            case 12:
              _overflow = _context5.sent;
              _offsets = getSideOffsets(_overflow, rects.floating);
              return _context5.abrupt("return", {
                data: {
                  escapedOffsets: _offsets,
                  escaped: isAnySideFullyClipped(_offsets)
                }
              });
            case 15:
              return _context5.abrupt("return", {});
            case 16:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }))();
    }
  };
};
function getBoundingRect(rects) {
  var minX = min.apply(void 0, _toConsumableArray(rects.map(function (rect) {
    return rect.left;
  })));
  var minY = min.apply(void 0, _toConsumableArray(rects.map(function (rect) {
    return rect.top;
  })));
  var maxX = max.apply(void 0, _toConsumableArray(rects.map(function (rect) {
    return rect.right;
  })));
  var maxY = max.apply(void 0, _toConsumableArray(rects.map(function (rect) {
    return rect.bottom;
  })));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  var sortedRects = rects.slice().sort(function (a, b) {
    return a.y - b.y;
  });
  var groups = [];
  var prevRect = null;
  for (var i = 0; i < sortedRects.length; i++) {
    var rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map(function (rect) {
    return rectToClientRect(getBoundingRect(rect));
  });
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
var inline = function inline(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options: options,
    fn: function fn(state) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var placement, elements, rects, platform, strategy, _options4, _options4$padding, padding, x, y, nativeClientRects, clientRects, fallback, paddingObject, getBoundingClientRect, resetRects;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              getBoundingClientRect = function _getBoundingClientRec() {
                // There are two rects and they are disjoined.
                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
                  // Find the first rect in which the point is fully inside.
                  return clientRects.find(function (rect) {
                    return x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom;
                  }) || fallback;
                }

                // There are 2 or more connected rects.
                if (clientRects.length >= 2) {
                  if (getMainAxisFromPlacement(placement) === 'x') {
                    var firstRect = clientRects[0];
                    var lastRect = clientRects[clientRects.length - 1];
                    var isTop = getSide(placement) === 'top';
                    var _top = firstRect.top;
                    var _bottom = lastRect.bottom;
                    var _left = isTop ? firstRect.left : lastRect.left;
                    var _right = isTop ? firstRect.right : lastRect.right;
                    var _width = _right - _left;
                    var _height = _bottom - _top;
                    return {
                      top: _top,
                      bottom: _bottom,
                      left: _left,
                      right: _right,
                      width: _width,
                      height: _height,
                      x: _left,
                      y: _top
                    };
                  }
                  var isLeftSide = getSide(placement) === 'left';
                  var maxRight = max.apply(void 0, _toConsumableArray(clientRects.map(function (rect) {
                    return rect.right;
                  })));
                  var minLeft = min.apply(void 0, _toConsumableArray(clientRects.map(function (rect) {
                    return rect.left;
                  })));
                  var measureRects = clientRects.filter(function (rect) {
                    return isLeftSide ? rect.left === minLeft : rect.right === maxRight;
                  });
                  var top = measureRects[0].top;
                  var bottom = measureRects[measureRects.length - 1].bottom;
                  var left = minLeft;
                  var right = maxRight;
                  var width = right - left;
                  var height = bottom - top;
                  return {
                    top: top,
                    bottom: bottom,
                    left: left,
                    right: right,
                    width: width,
                    height: height,
                    x: left,
                    y: top
                  };
                }
                return fallback;
              };
              placement = state.placement, elements = state.elements, rects = state.rects, platform = state.platform, strategy = state.strategy; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
              // ClientRect's bounds, despite the event listener being triggered. A
              // padding of 2 seems to handle this issue.
              _options4 = options, _options4$padding = _options4.padding, padding = _options4$padding === void 0 ? 2 : _options4$padding, x = _options4.x, y = _options4.y;
              _context6.t0 = Array;
              _context6.next = 6;
              return platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference);
            case 6:
              _context6.t1 = _context6.sent;
              if (_context6.t1) {
                _context6.next = 9;
                break;
              }
              _context6.t1 = [];
            case 9:
              _context6.t2 = _context6.t1;
              nativeClientRects = _context6.t0.from.call(_context6.t0, _context6.t2);
              clientRects = getRectsByLine(nativeClientRects);
              fallback = rectToClientRect(getBoundingRect(nativeClientRects));
              paddingObject = getSideObjectFromPadding(padding);
              _context6.next = 16;
              return platform.getElementRects({
                reference: {
                  getBoundingClientRect: getBoundingClientRect
                },
                floating: elements.floating,
                strategy: strategy
              });
            case 16:
              resetRects = _context6.sent;
              if (!(rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height)) {
                _context6.next = 19;
                break;
              }
              return _context6.abrupt("return", {
                reset: {
                  rects: resetRects
                }
              });
            case 19:
              return _context6.abrupt("return", {});
            case 20:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }))();
    }
  };
};
function convertValueToCoords(_x6, _x7) {
  return _convertValueToCoords.apply(this, arguments);
}
/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
function _convertValueToCoords() {
  _convertValueToCoords = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(state, value) {
    var placement, platform, elements, rtl, side, alignment, isVertical, mainAxisMulti, crossAxisMulti, rawValue, _ref6, mainAxis, crossAxis, alignmentAxis;
    return _regeneratorRuntime().wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          placement = state.placement, platform = state.platform, elements = state.elements;
          _context11.next = 3;
          return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);
        case 3:
          rtl = _context11.sent;
          side = getSide(placement);
          alignment = getAlignment(placement);
          isVertical = getMainAxisFromPlacement(placement) === 'x';
          mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
          crossAxisMulti = rtl && isVertical ? -1 : 1;
          rawValue = typeof value === 'function' ? value(state) : value; // eslint-disable-next-line prefer-const
          _ref6 = typeof rawValue === 'number' ? {
            mainAxis: rawValue,
            crossAxis: 0,
            alignmentAxis: null
          } : _objectSpread({
            mainAxis: 0,
            crossAxis: 0,
            alignmentAxis: null
          }, rawValue), mainAxis = _ref6.mainAxis, crossAxis = _ref6.crossAxis, alignmentAxis = _ref6.alignmentAxis;
          if (alignment && typeof alignmentAxis === 'number') {
            crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
          }
          return _context11.abrupt("return", isVertical ? {
            x: crossAxis * crossAxisMulti,
            y: mainAxis * mainAxisMulti
          } : {
            x: mainAxis * mainAxisMulti,
            y: crossAxis * crossAxisMulti
          });
        case 13:
        case "end":
          return _context11.stop();
      }
    }, _callee11);
  }));
  return _convertValueToCoords.apply(this, arguments);
}
var offset = function offset(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: 'offset',
    options: value,
    fn: function fn(state) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var x, y, diffCoords;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              x = state.x, y = state.y;
              _context7.next = 3;
              return convertValueToCoords(state, value);
            case 3:
              diffCoords = _context7.sent;
              return _context7.abrupt("return", {
                x: x + diffCoords.x,
                y: y + diffCoords.y,
                data: diffCoords
              });
            case 5:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }))();
    }
  };
};
function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
var shift = function shift(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options: options,
    fn: function fn(state) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var _objectSpread3;
        var x, y, placement, _options5, _options5$mainAxis, checkMainAxis, _options5$crossAxis, checkCrossAxis, _options5$limiter, limiter, detectOverflowOptions, coords, overflow, mainAxis, crossAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, _min, _max, _minSide, _maxSide, _min2, _max2, limitedCoords;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              x = state.x, y = state.y, placement = state.placement;
              _options5 = options, _options5$mainAxis = _options5.mainAxis, checkMainAxis = _options5$mainAxis === void 0 ? true : _options5$mainAxis, _options5$crossAxis = _options5.crossAxis, checkCrossAxis = _options5$crossAxis === void 0 ? false : _options5$crossAxis, _options5$limiter = _options5.limiter, limiter = _options5$limiter === void 0 ? {
                fn: function fn(_ref) {
                  var x = _ref.x,
                    y = _ref.y;
                  return {
                    x: x,
                    y: y
                  };
                }
              } : _options5$limiter, detectOverflowOptions = _objectWithoutProperties(_options5, _excluded4);
              coords = {
                x: x,
                y: y
              };
              _context8.next = 5;
              return detectOverflow(state, detectOverflowOptions);
            case 5:
              overflow = _context8.sent;
              mainAxis = getMainAxisFromPlacement(getSide(placement));
              crossAxis = getCrossAxis(mainAxis);
              mainAxisCoord = coords[mainAxis];
              crossAxisCoord = coords[crossAxis];
              if (checkMainAxis) {
                minSide = mainAxis === 'y' ? 'top' : 'left';
                maxSide = mainAxis === 'y' ? 'bottom' : 'right';
                _min = mainAxisCoord + overflow[minSide];
                _max = mainAxisCoord - overflow[maxSide];
                mainAxisCoord = within(_min, mainAxisCoord, _max);
              }
              if (checkCrossAxis) {
                _minSide = crossAxis === 'y' ? 'top' : 'left';
                _maxSide = crossAxis === 'y' ? 'bottom' : 'right';
                _min2 = crossAxisCoord + overflow[_minSide];
                _max2 = crossAxisCoord - overflow[_maxSide];
                crossAxisCoord = within(_min2, crossAxisCoord, _max2);
              }
              limitedCoords = limiter.fn(_objectSpread(_objectSpread({}, state), {}, (_objectSpread3 = {}, _defineProperty(_objectSpread3, mainAxis, mainAxisCoord), _defineProperty(_objectSpread3, crossAxis, crossAxisCoord), _objectSpread3)));
              return _context8.abrupt("return", _objectSpread(_objectSpread({}, limitedCoords), {}, {
                data: {
                  x: limitedCoords.x - x,
                  y: limitedCoords.y - y
                }
              }));
            case 14:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }))();
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
var limitShift = function limitShift(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options: options,
    fn: function fn(state) {
      var _ref5;
      var x = state.x,
        y = state.y,
        placement = state.placement,
        rects = state.rects,
        middlewareData = state.middlewareData;
      var _options6 = options,
        _options6$offset = _options6.offset,
        offset = _options6$offset === void 0 ? 0 : _options6$offset,
        _options6$mainAxis = _options6.mainAxis,
        checkMainAxis = _options6$mainAxis === void 0 ? true : _options6$mainAxis,
        _options6$crossAxis = _options6.crossAxis,
        checkCrossAxis = _options6$crossAxis === void 0 ? true : _options6$crossAxis;
      var coords = {
        x: x,
        y: y
      };
      var mainAxis = getMainAxisFromPlacement(placement);
      var crossAxis = getCrossAxis(mainAxis);
      var mainAxisCoord = coords[mainAxis];
      var crossAxisCoord = coords[crossAxis];
      var rawOffset = typeof offset === 'function' ? offset(state) : offset;
      var computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : _objectSpread({
        mainAxis: 0,
        crossAxis: 0
      }, rawOffset);
      if (checkMainAxis) {
        var len = mainAxis === 'y' ? 'height' : 'width';
        var limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        var limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        var _len = mainAxis === 'y' ? 'width' : 'height';
        var isOriginSide = ['top', 'left'].includes(getSide(placement));
        var _limitMin = rects.reference[crossAxis] - rects.floating[_len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        var _limitMax = rects.reference[crossAxis] + rects.reference[_len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < _limitMin) {
          crossAxisCoord = _limitMin;
        } else if (crossAxisCoord > _limitMax) {
          crossAxisCoord = _limitMax;
        }
      }
      return _ref5 = {}, _defineProperty(_ref5, mainAxis, mainAxisCoord), _defineProperty(_ref5, crossAxis, crossAxisCoord), _ref5;
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
var size = function size(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options: options,
    fn: function fn(state) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var placement, rects, platform, elements, _options7, _options7$apply, apply, detectOverflowOptions, overflow, side, alignment, axis, isXAxis, _rects$floating, width, height, heightSide, widthSide, overflowAvailableHeight, overflowAvailableWidth, noShift, availableHeight, availableWidth, maximumClippingWidth, maximumClippingHeight, xMin, xMax, yMin, yMax, nextDimensions;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements;
              _options7 = options, _options7$apply = _options7.apply, apply = _options7$apply === void 0 ? function () {} : _options7$apply, detectOverflowOptions = _objectWithoutProperties(_options7, _excluded5);
              _context9.next = 4;
              return detectOverflow(state, detectOverflowOptions);
            case 4:
              overflow = _context9.sent;
              side = getSide(placement);
              alignment = getAlignment(placement);
              axis = getMainAxisFromPlacement(placement);
              isXAxis = axis === 'x';
              _rects$floating = rects.floating, width = _rects$floating.width, height = _rects$floating.height;
              if (!(side === 'top' || side === 'bottom')) {
                _context9.next = 29;
                break;
              }
              heightSide = side;
              _context9.t0 = alignment;
              _context9.next = 15;
              return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);
            case 15:
              if (!_context9.sent) {
                _context9.next = 19;
                break;
              }
              _context9.t1 = 'start';
              _context9.next = 20;
              break;
            case 19:
              _context9.t1 = 'end';
            case 20:
              _context9.t2 = _context9.t1;
              if (!(_context9.t0 === _context9.t2)) {
                _context9.next = 25;
                break;
              }
              _context9.t3 = 'left';
              _context9.next = 26;
              break;
            case 25:
              _context9.t3 = 'right';
            case 26:
              widthSide = _context9.t3;
              _context9.next = 31;
              break;
            case 29:
              widthSide = side;
              heightSide = alignment === 'end' ? 'top' : 'bottom';
            case 31:
              overflowAvailableHeight = height - overflow[heightSide];
              overflowAvailableWidth = width - overflow[widthSide];
              noShift = !state.middlewareData.shift;
              availableHeight = overflowAvailableHeight;
              availableWidth = overflowAvailableWidth;
              if (isXAxis) {
                maximumClippingWidth = width - overflow.left - overflow.right;
                availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
              } else {
                maximumClippingHeight = height - overflow.top - overflow.bottom;
                availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
              }
              if (noShift && !alignment) {
                xMin = max(overflow.left, 0);
                xMax = max(overflow.right, 0);
                yMin = max(overflow.top, 0);
                yMax = max(overflow.bottom, 0);
                if (isXAxis) {
                  availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
                } else {
                  availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
                }
              }
              _context9.next = 40;
              return apply(_objectSpread(_objectSpread({}, state), {}, {
                availableWidth: availableWidth,
                availableHeight: availableHeight
              }));
            case 40:
              _context9.next = 42;
              return platform.getDimensions(elements.floating);
            case 42:
              nextDimensions = _context9.sent;
              if (!(width !== nextDimensions.width || height !== nextDimensions.height)) {
                _context9.next = 45;
                break;
              }
              return _context9.abrupt("return", {
                reset: {
                  rects: true
                }
              });
            case 45:
              return _context9.abrupt("return", {});
            case 46:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }))();
    }
  };
};


/***/ }),

/***/ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow),
/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),
/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),
/* harmony export */   computePosition: () => (/* binding */ computePosition),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),
/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip),
/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),
/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide),
/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline),
/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift),
/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),
/* harmony export */   platform: () => (/* binding */ platform),
/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift),
/* harmony export */   size: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size)
/* harmony export */ });
/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ "./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


function getWindow(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function getNodeName(node) {
  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support.
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  var _getComputedStyle$ = getComputedStyle$1(element),
    overflow = _getComputedStyle$.overflow,
    overflowX = _getComputedStyle$.overflowX,
    overflowY = _getComputedStyle$.overflowY,
    display = _getComputedStyle$.display;
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  var safari = isSafari();
  var css = getComputedStyle$1(element);

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || !safari && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !safari && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(function (value) {
    return (css.willChange || '').includes(value);
  }) || ['paint', 'layout', 'strict', 'content'].some(function (value) {
    return (css.contain || '').includes(value);
  });
}
function isSafari() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
var min = Math.min;
var max = Math.max;
var round = Math.round;
function getCssDimensions(element) {
  var css = getComputedStyle$1(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  var width = parseFloat(css.width) || 0;
  var height = parseFloat(css.height) || 0;
  var hasOffset = isHTMLElement(element);
  var offsetWidth = hasOffset ? element.offsetWidth : width;
  var offsetHeight = hasOffset ? element.offsetHeight : height;
  var shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width: width,
    height: height,
    fallback: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
var FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  var domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return FALLBACK_SCALE;
  }
  var rect = domElement.getBoundingClientRect();
  var _getCssDimensions = getCssDimensions(domElement),
    width = _getCssDimensions.width,
    height = _getCssDimensions.height,
    fallback = _getCssDimensions.fallback;
  var x = (fallback ? round(rect.width) : rect.width) / width;
  var y = (fallback ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x: x,
    y: y
  };
}
var noOffsets = {
  x: 0,
  y: 0
};
function getVisualOffsets(element, isFixed, floatingOffsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (isFixed === void 0) {
    isFixed = true;
  }
  if (!isSafari()) {
    return noOffsets;
  }
  var win = element ? getWindow(element) : window;
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== win) {
    return noOffsets;
  }
  return {
    x: ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0,
    y: ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0
  };
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var domElement = unwrapElement(element);
  var scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  var visualOffsets = getVisualOffsets(domElement, isFixedStrategy, offsetParent);
  var x = (clientRect.left + visualOffsets.x) / scale.x;
  var y = (clientRect.top + visualOffsets.y) / scale.y;
  var width = clientRect.width / scale.x;
  var height = clientRect.height / scale.y;
  if (domElement) {
    var win = getWindow(domElement);
    var offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    var currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      var iframeScale = getScale(currentIFrame);
      var iframeRect = currentIFrame.getBoundingClientRect();
      var css = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += iframeRect.x;
      y += iframeRect.y;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)({
    width: width,
    height: height,
    x: x,
    y: y
  });
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  var rect = _ref.rect,
    offsetParent = _ref.offsetParent,
    strategy = _ref.strategy;
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var scale = {
    x: 1,
    y: 1
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      var offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  var html = getDocumentElement(element);
  var scroll = getNodeScroll(element);
  var body = element.ownerDocument.body;
  var width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  var height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  var x = -scroll.scrollLeft + getWindowScrollBarX(element);
  var y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  var result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  var parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    // `getParentNode` will never return a `Document` due to the fallback
    // check, so it's either the <html> or <body> element.
    return parentNode.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  var scrollableAncestor = getNearestOverflowAncestor(node);
  var isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  var win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var visualViewportBased = isSafari();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  var clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  var top = clientRect.top + element.clientTop;
  var left = clientRect.left + element.clientLeft;
  var scale = isHTMLElement(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  var width = element.clientWidth * scale.x;
  var height = element.clientHeight * scale.y;
  var x = left * scale.x;
  var y = top * scale.y;
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  var rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    var visualOffsets = getVisualOffsets(element);
    rect = _objectSpread(_objectSpread({}, clippingAncestor), {}, {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    });
  }
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  var parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  var cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  var result = getOverflowAncestors(element).filter(function (el) {
    return isElement(el) && getNodeName(el) !== 'body';
  });
  var currentContainingBlockComputedStyle = null;
  var elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  var currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    var computedStyle = getComputedStyle$1(currentNode);
    var currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    var shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(function (ancestor) {
        return ancestor !== currentNode;
      });
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  var element = _ref.element,
    boundary = _ref.boundary,
    rootBoundary = _ref.rootBoundary,
    strategy = _ref.strategy;
  var elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  var clippingAncestors = [].concat(_toConsumableArray(elementClippingAncestors), [rootBoundary]);
  var firstClippingAncestor = clippingAncestors[0];
  var clippingRect = clippingAncestors.reduce(function (accRect, clippingAncestor) {
    var rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  var window = getWindow(element);
  if (!isHTMLElement(element)) {
    return window;
  }
  var offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var isFixed = strategy === 'fixed';
  var rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      var offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
var platform = {
  getClippingRect: getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement: isElement,
  getDimensions: getDimensions,
  getOffsetParent: getOffsetParent,
  getDocumentElement: getDocumentElement,
  getScale: getScale,
  getElementRects: function getElementRects(_ref) {
    var _this = this;
    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var reference, floating, strategy, getOffsetParentFn, getDimensionsFn;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            reference = _ref.reference, floating = _ref.floating, strategy = _ref.strategy;
            getOffsetParentFn = _this.getOffsetParent || getOffsetParent;
            getDimensionsFn = _this.getDimensions;
            _context.t0 = getRectRelativeToOffsetParent;
            _context.t1 = reference;
            _context.next = 7;
            return getOffsetParentFn(floating);
          case 7:
            _context.t2 = _context.sent;
            _context.t3 = strategy;
            _context.t4 = (0, _context.t0)(_context.t1, _context.t2, _context.t3);
            _context.t5 = _objectSpread;
            _context.t6 = {
              x: 0,
              y: 0
            };
            _context.next = 14;
            return getDimensionsFn(floating);
          case 14:
            _context.t7 = _context.sent;
            _context.t8 = (0, _context.t5)(_context.t6, _context.t7);
            return _context.abrupt("return", {
              reference: _context.t4,
              floating: _context.t8
            });
          case 17:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  },
  getClientRects: function getClientRects(element) {
    return Array.from(element.getClientRects());
  },
  isRTL: function isRTL(element) {
    return getComputedStyle$1(element).direction === 'rtl';
  }
};

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    _options$ancestorScro = _options.ancestorScroll,
    ancestorScroll = _options$ancestorScro === void 0 ? true : _options$ancestorScro,
    _options$ancestorResi = _options.ancestorResize,
    ancestorResize = _options$ancestorResi === void 0 ? true : _options$ancestorResi,
    _options$elementResiz = _options.elementResize,
    elementResize = _options$elementResiz === void 0 ? true : _options$elementResiz,
    _options$animationFra = _options.animationFrame,
    animationFrame = _options$animationFra === void 0 ? false : _options$animationFra;
  var ancestors = ancestorScroll || ancestorResize ? [].concat(_toConsumableArray(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), _toConsumableArray(getOverflowAncestors(floating))) : [];
  ancestors.forEach(function (ancestor) {
    // ignores Window, checks for [object VisualViewport]
    var isVisualViewport = !isElement(ancestor) && ancestor.toString().includes('V');
    if (ancestorScroll && (animationFrame ? isVisualViewport : true)) {
      ancestor.addEventListener('scroll', update, {
        passive: true
      });
    }
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  var observer = null;
  if (elementResize) {
    observer = new ResizeObserver(function () {
      update();
    });
    isElement(reference) && !animationFrame && observer.observe(reference);
    if (!isElement(reference) && reference.contextElement && !animationFrame) {
      observer.observe(reference.contextElement);
    }
    observer.observe(floating);
  }
  var frameId;
  var prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    var nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return function () {
    var _observer;
    ancestors.forEach(function (ancestor) {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */
var computePosition = function computePosition(reference, floating, options) {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  var cache = new Map();
  var mergedOptions = _objectSpread({
    platform: platform
  }, options);
  var platformWithCache = _objectSpread(_objectSpread({}, mergedOptions.platform), {}, {
    _c: cache
  });
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, _objectSpread(_objectSpread({}, mergedOptions), {}, {
    platform: platformWithCache
  }));
};


/***/ }),

/***/ "./node_modules/svelte/index.mjs":
/*!***************************************!*\
  !*** ./node_modules/svelte/index.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SvelteComponent: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev),
/* harmony export */   SvelteComponentTyped: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentTyped),
/* harmony export */   afterUpdate: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.afterUpdate),
/* harmony export */   beforeUpdate: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.beforeUpdate),
/* harmony export */   createEventDispatcher: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.createEventDispatcher),
/* harmony export */   getAllContexts: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.getAllContexts),
/* harmony export */   getContext: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.getContext),
/* harmony export */   hasContext: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.hasContext),
/* harmony export */   onDestroy: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onDestroy),
/* harmony export */   onMount: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onMount),
/* harmony export */   setContext: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.setContext),
/* harmony export */   tick: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.tick)
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");


/***/ }),

/***/ "./node_modules/svelte/internal/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/svelte/internal/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HtmlTag: () => (/* binding */ HtmlTag),
/* harmony export */   HtmlTagHydration: () => (/* binding */ HtmlTagHydration),
/* harmony export */   ResizeObserverSingleton: () => (/* binding */ ResizeObserverSingleton),
/* harmony export */   SvelteComponent: () => (/* binding */ SvelteComponent),
/* harmony export */   SvelteComponentDev: () => (/* binding */ SvelteComponentDev),
/* harmony export */   SvelteComponentTyped: () => (/* binding */ SvelteComponentTyped),
/* harmony export */   SvelteElement: () => (/* binding */ SvelteElement),
/* harmony export */   action_destroyer: () => (/* binding */ action_destroyer),
/* harmony export */   add_attribute: () => (/* binding */ add_attribute),
/* harmony export */   add_classes: () => (/* binding */ add_classes),
/* harmony export */   add_flush_callback: () => (/* binding */ add_flush_callback),
/* harmony export */   add_iframe_resize_listener: () => (/* binding */ add_iframe_resize_listener),
/* harmony export */   add_location: () => (/* binding */ add_location),
/* harmony export */   add_render_callback: () => (/* binding */ add_render_callback),
/* harmony export */   add_styles: () => (/* binding */ add_styles),
/* harmony export */   add_transform: () => (/* binding */ add_transform),
/* harmony export */   afterUpdate: () => (/* binding */ afterUpdate),
/* harmony export */   append: () => (/* binding */ append),
/* harmony export */   append_dev: () => (/* binding */ append_dev),
/* harmony export */   append_empty_stylesheet: () => (/* binding */ append_empty_stylesheet),
/* harmony export */   append_hydration: () => (/* binding */ append_hydration),
/* harmony export */   append_hydration_dev: () => (/* binding */ append_hydration_dev),
/* harmony export */   append_styles: () => (/* binding */ append_styles),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   attr: () => (/* binding */ attr),
/* harmony export */   attr_dev: () => (/* binding */ attr_dev),
/* harmony export */   attribute_to_object: () => (/* binding */ attribute_to_object),
/* harmony export */   beforeUpdate: () => (/* binding */ beforeUpdate),
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   binding_callbacks: () => (/* binding */ binding_callbacks),
/* harmony export */   blank_object: () => (/* binding */ blank_object),
/* harmony export */   bubble: () => (/* binding */ bubble),
/* harmony export */   check_outros: () => (/* binding */ check_outros),
/* harmony export */   children: () => (/* binding */ children),
/* harmony export */   claim_comment: () => (/* binding */ claim_comment),
/* harmony export */   claim_component: () => (/* binding */ claim_component),
/* harmony export */   claim_element: () => (/* binding */ claim_element),
/* harmony export */   claim_html_tag: () => (/* binding */ claim_html_tag),
/* harmony export */   claim_space: () => (/* binding */ claim_space),
/* harmony export */   claim_svg_element: () => (/* binding */ claim_svg_element),
/* harmony export */   claim_text: () => (/* binding */ claim_text),
/* harmony export */   clear_loops: () => (/* binding */ clear_loops),
/* harmony export */   comment: () => (/* binding */ comment),
/* harmony export */   component_subscribe: () => (/* binding */ component_subscribe),
/* harmony export */   compute_rest_props: () => (/* binding */ compute_rest_props),
/* harmony export */   compute_slots: () => (/* binding */ compute_slots),
/* harmony export */   construct_svelte_component: () => (/* binding */ construct_svelte_component),
/* harmony export */   construct_svelte_component_dev: () => (/* binding */ construct_svelte_component_dev),
/* harmony export */   contenteditable_truthy_values: () => (/* binding */ contenteditable_truthy_values),
/* harmony export */   createEventDispatcher: () => (/* binding */ createEventDispatcher),
/* harmony export */   create_animation: () => (/* binding */ create_animation),
/* harmony export */   create_bidirectional_transition: () => (/* binding */ create_bidirectional_transition),
/* harmony export */   create_component: () => (/* binding */ create_component),
/* harmony export */   create_in_transition: () => (/* binding */ create_in_transition),
/* harmony export */   create_out_transition: () => (/* binding */ create_out_transition),
/* harmony export */   create_slot: () => (/* binding */ create_slot),
/* harmony export */   create_ssr_component: () => (/* binding */ create_ssr_component),
/* harmony export */   current_component: () => (/* binding */ current_component),
/* harmony export */   custom_event: () => (/* binding */ custom_event),
/* harmony export */   dataset_dev: () => (/* binding */ dataset_dev),
/* harmony export */   debug: () => (/* binding */ debug),
/* harmony export */   destroy_block: () => (/* binding */ destroy_block),
/* harmony export */   destroy_component: () => (/* binding */ destroy_component),
/* harmony export */   destroy_each: () => (/* binding */ destroy_each),
/* harmony export */   detach: () => (/* binding */ detach),
/* harmony export */   detach_after_dev: () => (/* binding */ detach_after_dev),
/* harmony export */   detach_before_dev: () => (/* binding */ detach_before_dev),
/* harmony export */   detach_between_dev: () => (/* binding */ detach_between_dev),
/* harmony export */   detach_dev: () => (/* binding */ detach_dev),
/* harmony export */   dirty_components: () => (/* binding */ dirty_components),
/* harmony export */   dispatch_dev: () => (/* binding */ dispatch_dev),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   element: () => (/* binding */ element),
/* harmony export */   element_is: () => (/* binding */ element_is),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   end_hydrating: () => (/* binding */ end_hydrating),
/* harmony export */   escape: () => (/* binding */ escape),
/* harmony export */   escape_attribute_value: () => (/* binding */ escape_attribute_value),
/* harmony export */   escape_object: () => (/* binding */ escape_object),
/* harmony export */   exclude_internal_props: () => (/* binding */ exclude_internal_props),
/* harmony export */   fix_and_destroy_block: () => (/* binding */ fix_and_destroy_block),
/* harmony export */   fix_and_outro_and_destroy_block: () => (/* binding */ fix_and_outro_and_destroy_block),
/* harmony export */   fix_position: () => (/* binding */ fix_position),
/* harmony export */   flush: () => (/* binding */ flush),
/* harmony export */   flush_render_callbacks: () => (/* binding */ flush_render_callbacks),
/* harmony export */   getAllContexts: () => (/* binding */ getAllContexts),
/* harmony export */   getContext: () => (/* binding */ getContext),
/* harmony export */   get_all_dirty_from_scope: () => (/* binding */ get_all_dirty_from_scope),
/* harmony export */   get_binding_group_value: () => (/* binding */ get_binding_group_value),
/* harmony export */   get_current_component: () => (/* binding */ get_current_component),
/* harmony export */   get_custom_elements_slots: () => (/* binding */ get_custom_elements_slots),
/* harmony export */   get_root_for_style: () => (/* binding */ get_root_for_style),
/* harmony export */   get_slot_changes: () => (/* binding */ get_slot_changes),
/* harmony export */   get_spread_object: () => (/* binding */ get_spread_object),
/* harmony export */   get_spread_update: () => (/* binding */ get_spread_update),
/* harmony export */   get_store_value: () => (/* binding */ get_store_value),
/* harmony export */   globals: () => (/* binding */ globals),
/* harmony export */   group_outros: () => (/* binding */ group_outros),
/* harmony export */   handle_promise: () => (/* binding */ handle_promise),
/* harmony export */   hasContext: () => (/* binding */ hasContext),
/* harmony export */   has_prop: () => (/* binding */ has_prop),
/* harmony export */   head_selector: () => (/* binding */ head_selector),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   init_binding_group: () => (/* binding */ init_binding_group),
/* harmony export */   init_binding_group_dynamic: () => (/* binding */ init_binding_group_dynamic),
/* harmony export */   insert: () => (/* binding */ insert),
/* harmony export */   insert_dev: () => (/* binding */ insert_dev),
/* harmony export */   insert_hydration: () => (/* binding */ insert_hydration),
/* harmony export */   insert_hydration_dev: () => (/* binding */ insert_hydration_dev),
/* harmony export */   intros: () => (/* binding */ intros),
/* harmony export */   invalid_attribute_name_character: () => (/* binding */ invalid_attribute_name_character),
/* harmony export */   is_client: () => (/* binding */ is_client),
/* harmony export */   is_crossorigin: () => (/* binding */ is_crossorigin),
/* harmony export */   is_empty: () => (/* binding */ is_empty),
/* harmony export */   is_function: () => (/* binding */ is_function),
/* harmony export */   is_promise: () => (/* binding */ is_promise),
/* harmony export */   is_void: () => (/* binding */ is_void),
/* harmony export */   listen: () => (/* binding */ listen),
/* harmony export */   listen_dev: () => (/* binding */ listen_dev),
/* harmony export */   loop: () => (/* binding */ loop),
/* harmony export */   loop_guard: () => (/* binding */ loop_guard),
/* harmony export */   merge_ssr_styles: () => (/* binding */ merge_ssr_styles),
/* harmony export */   missing_component: () => (/* binding */ missing_component),
/* harmony export */   mount_component: () => (/* binding */ mount_component),
/* harmony export */   noop: () => (/* binding */ noop),
/* harmony export */   not_equal: () => (/* binding */ not_equal),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   null_to_empty: () => (/* binding */ null_to_empty),
/* harmony export */   object_without_properties: () => (/* binding */ object_without_properties),
/* harmony export */   onDestroy: () => (/* binding */ onDestroy),
/* harmony export */   onMount: () => (/* binding */ onMount),
/* harmony export */   once: () => (/* binding */ once),
/* harmony export */   outro_and_destroy_block: () => (/* binding */ outro_and_destroy_block),
/* harmony export */   prevent_default: () => (/* binding */ prevent_default),
/* harmony export */   prop_dev: () => (/* binding */ prop_dev),
/* harmony export */   query_selector_all: () => (/* binding */ query_selector_all),
/* harmony export */   raf: () => (/* binding */ raf),
/* harmony export */   resize_observer_border_box: () => (/* binding */ resize_observer_border_box),
/* harmony export */   resize_observer_content_box: () => (/* binding */ resize_observer_content_box),
/* harmony export */   resize_observer_device_pixel_content_box: () => (/* binding */ resize_observer_device_pixel_content_box),
/* harmony export */   run: () => (/* binding */ run),
/* harmony export */   run_all: () => (/* binding */ run_all),
/* harmony export */   safe_not_equal: () => (/* binding */ safe_not_equal),
/* harmony export */   schedule_update: () => (/* binding */ schedule_update),
/* harmony export */   select_multiple_value: () => (/* binding */ select_multiple_value),
/* harmony export */   select_option: () => (/* binding */ select_option),
/* harmony export */   select_options: () => (/* binding */ select_options),
/* harmony export */   select_value: () => (/* binding */ select_value),
/* harmony export */   self: () => (/* binding */ self),
/* harmony export */   setContext: () => (/* binding */ setContext),
/* harmony export */   set_attributes: () => (/* binding */ set_attributes),
/* harmony export */   set_current_component: () => (/* binding */ set_current_component),
/* harmony export */   set_custom_element_data: () => (/* binding */ set_custom_element_data),
/* harmony export */   set_custom_element_data_map: () => (/* binding */ set_custom_element_data_map),
/* harmony export */   set_data: () => (/* binding */ set_data),
/* harmony export */   set_data_contenteditable: () => (/* binding */ set_data_contenteditable),
/* harmony export */   set_data_contenteditable_dev: () => (/* binding */ set_data_contenteditable_dev),
/* harmony export */   set_data_dev: () => (/* binding */ set_data_dev),
/* harmony export */   set_data_maybe_contenteditable: () => (/* binding */ set_data_maybe_contenteditable),
/* harmony export */   set_data_maybe_contenteditable_dev: () => (/* binding */ set_data_maybe_contenteditable_dev),
/* harmony export */   set_dynamic_element_data: () => (/* binding */ set_dynamic_element_data),
/* harmony export */   set_input_type: () => (/* binding */ set_input_type),
/* harmony export */   set_input_value: () => (/* binding */ set_input_value),
/* harmony export */   set_now: () => (/* binding */ set_now),
/* harmony export */   set_raf: () => (/* binding */ set_raf),
/* harmony export */   set_store_value: () => (/* binding */ set_store_value),
/* harmony export */   set_style: () => (/* binding */ set_style),
/* harmony export */   set_svg_attributes: () => (/* binding */ set_svg_attributes),
/* harmony export */   space: () => (/* binding */ space),
/* harmony export */   split_css_unit: () => (/* binding */ split_css_unit),
/* harmony export */   spread: () => (/* binding */ spread),
/* harmony export */   src_url_equal: () => (/* binding */ src_url_equal),
/* harmony export */   start_hydrating: () => (/* binding */ start_hydrating),
/* harmony export */   stop_immediate_propagation: () => (/* binding */ stop_immediate_propagation),
/* harmony export */   stop_propagation: () => (/* binding */ stop_propagation),
/* harmony export */   subscribe: () => (/* binding */ subscribe),
/* harmony export */   svg_element: () => (/* binding */ svg_element),
/* harmony export */   text: () => (/* binding */ text),
/* harmony export */   tick: () => (/* binding */ tick),
/* harmony export */   time_ranges_to_array: () => (/* binding */ time_ranges_to_array),
/* harmony export */   to_number: () => (/* binding */ to_number),
/* harmony export */   toggle_class: () => (/* binding */ toggle_class),
/* harmony export */   transition_in: () => (/* binding */ transition_in),
/* harmony export */   transition_out: () => (/* binding */ transition_out),
/* harmony export */   trusted: () => (/* binding */ trusted),
/* harmony export */   update_await_block_branch: () => (/* binding */ update_await_block_branch),
/* harmony export */   update_keyed_each: () => (/* binding */ update_keyed_each),
/* harmony export */   update_slot: () => (/* binding */ update_slot),
/* harmony export */   update_slot_base: () => (/* binding */ update_slot_base),
/* harmony export */   validate_component: () => (/* binding */ validate_component),
/* harmony export */   validate_dynamic_element: () => (/* binding */ validate_dynamic_element),
/* harmony export */   validate_each_argument: () => (/* binding */ validate_each_argument),
/* harmony export */   validate_each_keys: () => (/* binding */ validate_each_keys),
/* harmony export */   validate_slots: () => (/* binding */ validate_slots),
/* harmony export */   validate_store: () => (/* binding */ validate_store),
/* harmony export */   validate_void_dynamic_element: () => (/* binding */ validate_void_dynamic_element),
/* harmony export */   xlink_attr: () => (/* binding */ xlink_attr)
/* harmony export */ });
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function noop() {}
var identity = function identity(x) {
  return x;
};
function assign(tar, src) {
  // @ts-ignore
  for (var k in src) tar[k] = src[k];
  return tar;
}
// Adapted from https://github.com/then/is-promise/blob/master/index.js
// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE
function is_promise(value) {
  return !!value && (_typeof(value) === 'object' || typeof value === 'function') && typeof value.then === 'function';
}
function add_location(element, file, line, column, _char) {
  element.__svelte_meta = {
    loc: {
      file: file,
      line: line,
      column: column,
      "char": _char
    }
  };
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === 'function';
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement('a');
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function not_equal(a, b) {
  return a != a ? b == b : a !== b;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== 'function') {
    throw new Error("'".concat(name, "' is not a store with a 'subscribe' method"));
  }
}
function subscribe(store) {
  if (store == null) {
    return noop;
  }
  for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    callbacks[_key - 1] = arguments[_key];
  }
  var unsub = store.subscribe.apply(store, callbacks);
  return unsub.unsubscribe ? function () {
    return unsub.unsubscribe();
  } : unsub;
}
function get_store_value(store) {
  var value;
  subscribe(store, function (_) {
    return value = _;
  })();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    var slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    var lets = definition[2](fn(dirty));
    if ($$scope.dirty === undefined) {
      return lets;
    }
    if (_typeof(lets) === 'object') {
      var merged = [];
      var len = Math.max($$scope.dirty.length, lets.length);
      for (var i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    var slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
  var slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
  update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    var dirty = [];
    var length = $$scope.ctx.length / 32;
    for (var i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  var result = {};
  for (var k in props) if (k[0] !== '$') result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  var rest = {};
  keys = new Set(keys);
  for (var k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
  return rest;
}
function compute_slots(slots) {
  var result = {};
  for (var key in slots) {
    result[key] = true;
  }
  return result;
}
function once(fn) {
  var ran = false;
  return function () {
    if (ran) return;
    ran = true;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    fn.call.apply(fn, [this].concat(args));
  };
}
function null_to_empty(value) {
  return value == null ? '' : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
var has_prop = function has_prop(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
function split_css_unit(value) {
  var split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];
}
var contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];
var is_client = typeof window !== 'undefined';
var now = is_client ? function () {
  return window.performance.now();
} : function () {
  return Date.now();
};
var raf = is_client ? function (cb) {
  return requestAnimationFrame(cb);
} : noop;
// used internally for testing
function set_now(fn) {
  now = fn;
}
function set_raf(fn) {
  raf = fn;
}
var tasks = new Set();
function run_tasks(now) {
  tasks.forEach(function (task) {
    if (!task.c(now)) {
      tasks["delete"](task);
      task.f();
    }
  });
  if (tasks.size !== 0) raf(run_tasks);
}
/**
 * For testing purposes only!
 */
function clear_loops() {
  tasks.clear();
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
  var task;
  if (tasks.size === 0) raf(run_tasks);
  return {
    promise: new Promise(function (fulfill) {
      tasks.add(task = {
        c: callback,
        f: fulfill
      });
    }),
    abort: function abort() {
      tasks["delete"](task);
    }
  };
}
var globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;

/**
 * Resize observer singleton.
 * One listener per element only!
 * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ
 */
var ResizeObserverSingleton = /*#__PURE__*/function () {
  function ResizeObserverSingleton(options) {
    _classCallCheck(this, ResizeObserverSingleton);
    this.options = options;
    this._listeners = 'WeakMap' in globals ? new WeakMap() : undefined;
  }
  _createClass(ResizeObserverSingleton, [{
    key: "observe",
    value: function observe(element, listener) {
      var _this = this;
      this._listeners.set(element, listener);
      this._getObserver().observe(element, this.options);
      return function () {
        _this._listeners["delete"](element);
        _this._observer.unobserve(element); // this line can probably be removed
      };
    }
  }, {
    key: "_getObserver",
    value: function _getObserver() {
      var _this2 = this;
      var _a;
      return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver(function (entries) {
        var _a;
        var _iterator = _createForOfIteratorHelper(entries),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var entry = _step.value;
            ResizeObserverSingleton.entries.set(entry.target, entry);
            (_a = _this2._listeners.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
  }]);
  return ResizeObserverSingleton;
}(); // Needs to be written like this to pass the tree-shake-test
ResizeObserverSingleton.entries = 'WeakMap' in globals ? new WeakMap() : undefined;

// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
// at the end of hydration without touching the remaining nodes.
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function upper_bound(low, high, key, value) {
  // Return first index of value larger than input value in the range [low, high)
  while (low < high) {
    var mid = low + (high - low >> 1);
    if (key(mid) <= value) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function init_hydrate(target) {
  if (target.hydrate_init) return;
  target.hydrate_init = true;
  // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>
  var children = target.childNodes;
  // If target is <head>, there may be children without claim_order
  if (target.nodeName === 'HEAD') {
    var myChildren = [];
    for (var i = 0; i < children.length; i++) {
      var node = children[i];
      if (node.claim_order !== undefined) {
        myChildren.push(node);
      }
    }
    children = myChildren;
  }
  /*
  * Reorder claimed children optimally.
  * We can reorder claimed children optimally by finding the longest subsequence of
  * nodes that are already claimed in order and only moving the rest. The longest
  * subsequence of nodes that are claimed in order can be found by
  * computing the longest increasing subsequence of .claim_order values.
  *
  * This algorithm is optimal in generating the least amount of reorder operations
  * possible.
  *
  * Proof:
  * We know that, given a set of reordering operations, the nodes that do not move
  * always form an increasing subsequence, since they do not move among each other
  * meaning that they must be already ordered among each other. Thus, the maximal
  * set of nodes that do not move form a longest increasing subsequence.
  */
  // Compute longest increasing subsequence
  // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
  var m = new Int32Array(children.length + 1);
  // Predecessor indices + 1
  var p = new Int32Array(children.length);
  m[0] = -1;
  var longest = 0;
  for (var _i = 0; _i < children.length; _i++) {
    var current = children[_i].claim_order;
    // Find the largest subsequence length such that it ends in a value less than our current value
    // upper_bound returns first greater value, so we subtract one
    // with fast path for when we are on the current longest subsequence
    var seqLen = (longest > 0 && children[m[longest]].claim_order <= current ? longest + 1 : upper_bound(1, longest, function (idx) {
      return children[m[idx]].claim_order;
    }, current)) - 1;
    p[_i] = m[seqLen] + 1;
    var newLen = seqLen + 1;
    // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
    m[newLen] = _i;
    longest = Math.max(newLen, longest);
  }
  // The longest increasing subsequence of nodes (initially reversed)
  var lis = [];
  // The rest of the nodes, nodes that will be moved
  var toMove = [];
  var last = children.length - 1;
  for (var cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
    lis.push(children[cur - 1]);
    for (; last >= cur; last--) {
      toMove.push(children[last]);
    }
    last--;
  }
  for (; last >= 0; last--) {
    toMove.push(children[last]);
  }
  lis.reverse();
  // We sort the nodes being moved to guarantee that their insertion order matches the claim order
  toMove.sort(function (a, b) {
    return a.claim_order - b.claim_order;
  });
  // Finally, we move the nodes
  for (var _i2 = 0, j = 0; _i2 < toMove.length; _i2++) {
    while (j < lis.length && toMove[_i2].claim_order >= lis[j].claim_order) {
      j++;
    }
    var anchor = j < lis.length ? lis[j] : null;
    target.insertBefore(toMove[_i2], anchor);
  }
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  var append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    var style = element('style');
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node) return document;
  var root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  var style_element = element('style');
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function append_hydration(target, node) {
  if (is_hydrating) {
    init_hydrate(target);
    if (target.actual_end_child === undefined || target.actual_end_child !== null && target.actual_end_child.parentNode !== target) {
      target.actual_end_child = target.firstChild;
    }
    // Skip nodes of undefined ordering
    while (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {
      target.actual_end_child = target.actual_end_child.nextSibling;
    }
    if (node !== target.actual_end_child) {
      // We only insert if the ordering of this node should be modified or the parent node is not target
      if (node.claim_order !== undefined || node.parentNode !== target) {
        target.insertBefore(node, target.actual_end_child);
      }
    } else {
      target.actual_end_child = node.nextSibling;
    }
  } else if (node.parentNode !== target || node.nextSibling !== null) {
    target.appendChild(node);
  }
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function insert_hydration(target, node, anchor) {
  if (is_hydrating && !anchor) {
    append_hydration(target, node);
  } else if (node.parentNode !== target || node.nextSibling != anchor) {
    target.insertBefore(node, anchor || null);
  }
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (var i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function element_is(name, is) {
  return document.createElement(name, {
    is: is
  });
}
function object_without_properties(obj, exclude) {
  var target = {};
  for (var k in obj) {
    if (has_prop(obj, k)
    // @ts-ignore
    && exclude.indexOf(k) === -1) {
      // @ts-ignore
      target[k] = obj[k];
    }
  }
  return target;
}
function svg_element(name) {
  return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(' ');
}
function empty() {
  return text('');
}
function comment(content) {
  return document.createComment(content);
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return function () {
    return node.removeEventListener(event, handler, options);
  };
}
function prevent_default(fn) {
  return function (event) {
    event.preventDefault();
    // @ts-ignore
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function (event) {
    event.stopPropagation();
    // @ts-ignore
    return fn.call(this, event);
  };
}
function stop_immediate_propagation(fn) {
  return function (event) {
    event.stopImmediatePropagation();
    // @ts-ignore
    return fn.call(this, event);
  };
}
function self(fn) {
  return function (event) {
    // @ts-ignore
    if (event.target === this) fn.call(this, event);
  };
}
function trusted(fn) {
  return function (event) {
    // @ts-ignore
    if (event.isTrusted) fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
/**
 * List of attributes that should always be set through the attr method,
 * because updating them through the property setter doesn't work reliably.
 * In the example of `width`/`height`, the problem is that the setter only
 * accepts numeric values, but the attribute can also be set to a string like `50%`.
 * If this list becomes too big, rethink this approach.
 */
var always_set_through_set_attribute = ['width', 'height'];
function set_attributes(node, attributes) {
  // @ts-ignore
  var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (var key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === 'style') {
      node.style.cssText = attributes[key];
    } else if (key === '__value') {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_svg_attributes(node, attributes) {
  for (var key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function set_custom_element_data_map(node, data_map) {
  Object.keys(data_map).forEach(function (key) {
    set_custom_element_data(node, key, data_map[key]);
  });
}
function set_custom_element_data(node, prop, value) {
  if (prop in node) {
    node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
  } else {
    attr(node, prop, value);
  }
}
function set_dynamic_element_data(tag) {
  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}
function xlink_attr(node, attribute, value) {
  node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}
function get_binding_group_value(group, __value, checked) {
  var value = new Set();
  for (var i = 0; i < group.length; i += 1) {
    if (group[i].checked) value.add(group[i].__value);
  }
  if (!checked) {
    value["delete"](__value);
  }
  return Array.from(value);
}
function init_binding_group(group) {
  var _inputs;
  return {
    /* push */p: function p() {
      for (var _len3 = arguments.length, inputs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        inputs[_key3] = arguments[_key3];
      }
      _inputs = inputs;
      _inputs.forEach(function (input) {
        return group.push(input);
      });
    },
    /* remove */r: function r() {
      _inputs.forEach(function (input) {
        return group.splice(group.indexOf(input), 1);
      });
    }
  };
}
function init_binding_group_dynamic(group, indexes) {
  var _group = get_binding_group(group);
  var _inputs;
  function get_binding_group(group) {
    for (var i = 0; i < indexes.length; i++) {
      group = group[indexes[i]] = group[indexes[i]] || [];
    }
    return group;
  }
  function push() {
    _inputs.forEach(function (input) {
      return _group.push(input);
    });
  }
  function remove() {
    _inputs.forEach(function (input) {
      return _group.splice(_group.indexOf(input), 1);
    });
  }
  return {
    /* update */u: function u(new_indexes) {
      indexes = new_indexes;
      var new_group = get_binding_group(group);
      if (new_group !== _group) {
        remove();
        _group = new_group;
        push();
      }
    },
    /* push */p: function p() {
      for (var _len4 = arguments.length, inputs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        inputs[_key4] = arguments[_key4];
      }
      _inputs = inputs;
      push();
    },
    /* remove */r: remove
  };
}
function to_number(value) {
  return value === '' ? null : +value;
}
function time_ranges_to_array(ranges) {
  var array = [];
  for (var i = 0; i < ranges.length; i += 1) {
    array.push({
      start: ranges.start(i),
      end: ranges.end(i)
    });
  }
  return array;
}
function children(element) {
  return Array.from(element.childNodes);
}
function init_claim_info(nodes) {
  if (nodes.claim_info === undefined) {
    nodes.claim_info = {
      last_index: 0,
      total_claimed: 0
    };
  }
}
function claim_node(nodes, predicate, processNode, createNode) {
  var dontUpdateLastIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  // Try to find nodes in an order such that we lengthen the longest increasing subsequence
  init_claim_info(nodes);
  var resultNode = function () {
    // We first try to find an element after the previous one
    for (var i = nodes.claim_info.last_index; i < nodes.length; i++) {
      var node = nodes[i];
      if (predicate(node)) {
        var replacement = processNode(node);
        if (replacement === undefined) {
          nodes.splice(i, 1);
        } else {
          nodes[i] = replacement;
        }
        if (!dontUpdateLastIndex) {
          nodes.claim_info.last_index = i;
        }
        return node;
      }
    }
    // Otherwise, we try to find one before
    // We iterate in reverse so that we don't go too far back
    for (var _i3 = nodes.claim_info.last_index - 1; _i3 >= 0; _i3--) {
      var _node = nodes[_i3];
      if (predicate(_node)) {
        var _replacement = processNode(_node);
        if (_replacement === undefined) {
          nodes.splice(_i3, 1);
        } else {
          nodes[_i3] = _replacement;
        }
        if (!dontUpdateLastIndex) {
          nodes.claim_info.last_index = _i3;
        } else if (_replacement === undefined) {
          // Since we spliced before the last_index, we decrease it
          nodes.claim_info.last_index--;
        }
        return _node;
      }
    }
    // If we can't find any matching node, we create a new one
    return createNode();
  }();
  resultNode.claim_order = nodes.claim_info.total_claimed;
  nodes.claim_info.total_claimed += 1;
  return resultNode;
}
function claim_element_base(nodes, name, attributes, create_element) {
  return claim_node(nodes, function (node) {
    return node.nodeName === name;
  }, function (node) {
    var remove = [];
    for (var j = 0; j < node.attributes.length; j++) {
      var attribute = node.attributes[j];
      if (!attributes[attribute.name]) {
        remove.push(attribute.name);
      }
    }
    remove.forEach(function (v) {
      return node.removeAttribute(v);
    });
    return undefined;
  }, function () {
    return create_element(name);
  });
}
function claim_element(nodes, name, attributes) {
  return claim_element_base(nodes, name, attributes, element);
}
function claim_svg_element(nodes, name, attributes) {
  return claim_element_base(nodes, name, attributes, svg_element);
}
function claim_text(nodes, data) {
  return claim_node(nodes, function (node) {
    return node.nodeType === 3;
  }, function (node) {
    var dataStr = '' + data;
    if (node.data.startsWith(dataStr)) {
      if (node.data.length !== dataStr.length) {
        return node.splitText(dataStr.length);
      }
    } else {
      node.data = dataStr;
    }
  }, function () {
    return text(data);
  }, true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
  );
}

function claim_space(nodes) {
  return claim_text(nodes, ' ');
}
function claim_comment(nodes, data) {
  return claim_node(nodes, function (node) {
    return node.nodeType === 8;
  }, function (node) {
    node.data = '' + data;
    return undefined;
  }, function () {
    return comment(data);
  }, true);
}
function find_comment(nodes, text, start) {
  for (var i = start; i < nodes.length; i += 1) {
    var node = nodes[i];
    if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {
      return i;
    }
  }
  return nodes.length;
}
function claim_html_tag(nodes, is_svg) {
  // find html opening tag
  var start_index = find_comment(nodes, 'HTML_TAG_START', 0);
  var end_index = find_comment(nodes, 'HTML_TAG_END', start_index);
  if (start_index === end_index) {
    return new HtmlTagHydration(undefined, is_svg);
  }
  init_claim_info(nodes);
  var html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
  detach(html_tag_nodes[0]);
  detach(html_tag_nodes[html_tag_nodes.length - 1]);
  var claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
  var _iterator2 = _createForOfIteratorHelper(claimed_nodes),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var n = _step2.value;
      n.claim_order = nodes.claim_info.total_claimed;
      nodes.claim_info.total_claimed += 1;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return new HtmlTagHydration(claimed_nodes, is_svg);
}
function set_data(text, data) {
  data = '' + data;
  if (text.data === data) return;
  text.data = data;
}
function set_data_contenteditable(text, data) {
  data = '' + data;
  if (text.wholeText === data) return;
  text.data = data;
}
function set_data_maybe_contenteditable(text, data, attr_value) {
  if (~contenteditable_truthy_values.indexOf(attr_value)) {
    set_data_contenteditable(text, data);
  } else {
    set_data(text, data);
  }
}
function set_input_value(input, value) {
  input.value = value == null ? '' : value;
}
function set_input_type(input, type) {
  try {
    input.type = type;
  } catch (e) {
    // do nothing
  }
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? 'important' : '');
  }
}
function select_option(select, value, mounting) {
  for (var i = 0; i < select.options.length; i += 1) {
    var option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== undefined) {
    select.selectedIndex = -1; // no option should be selected
  }
}

function select_options(select, value) {
  for (var i = 0; i < select.options.length; i += 1) {
    var option = select.options[i];
    option.selected = ~value.indexOf(option.__value);
  }
}
function select_value(select) {
  var selected_option = select.querySelector(':checked');
  return selected_option && selected_option.__value;
}
function select_multiple_value(select) {
  return [].map.call(select.querySelectorAll(':checked'), function (option) {
    return option.__value;
  });
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead
var crossorigin;
function is_crossorigin() {
  if (crossorigin === undefined) {
    crossorigin = false;
    try {
      if (typeof window !== 'undefined' && window.parent) {
        void window.parent.document;
      }
    } catch (error) {
      crossorigin = true;
    }
  }
  return crossorigin;
}
function add_iframe_resize_listener(node, fn) {
  var computed_style = getComputedStyle(node);
  if (computed_style.position === 'static') {
    node.style.position = 'relative';
  }
  var iframe = element('iframe');
  iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + 'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
  iframe.setAttribute('aria-hidden', 'true');
  iframe.tabIndex = -1;
  var crossorigin = is_crossorigin();
  var unsubscribe;
  if (crossorigin) {
    iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
    unsubscribe = listen(window, 'message', function (event) {
      if (event.source === iframe.contentWindow) fn();
    });
  } else {
    iframe.src = 'about:blank';
    iframe.onload = function () {
      unsubscribe = listen(iframe.contentWindow, 'resize', fn);
      // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)
      // see https://github.com/sveltejs/svelte/issues/4233
      fn();
    };
  }
  append(node, iframe);
  return function () {
    if (crossorigin) {
      unsubscribe();
    } else if (unsubscribe && iframe.contentWindow) {
      unsubscribe();
    }
    detach(iframe);
  };
}
var resize_observer_content_box = /* @__PURE__ */new ResizeObserverSingleton({
  box: 'content-box'
});
var resize_observer_border_box = /* @__PURE__ */new ResizeObserverSingleton({
  box: 'border-box'
});
var resize_observer_device_pixel_content_box = /* @__PURE__ */new ResizeObserverSingleton({
  box: 'device-pixel-content-box'
});
function toggle_class(element, name, toggle) {
  element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    _ref$bubbles = _ref.bubbles,
    bubbles = _ref$bubbles === void 0 ? false : _ref$bubbles,
    _ref$cancelable = _ref.cancelable,
    cancelable = _ref$cancelable === void 0 ? false : _ref$cancelable;
  var e = document.createEvent('CustomEvent');
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
function query_selector_all(selector) {
  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;
  return Array.from(parent.querySelectorAll(selector));
}
function head_selector(nodeId, head) {
  var result = [];
  var started = 0;
  var _iterator3 = _createForOfIteratorHelper(head.childNodes),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var node = _step3.value;
      if (node.nodeType === 8 /* comment node */) {
        var _comment = node.textContent.trim();
        if (_comment === "HEAD_".concat(nodeId, "_END")) {
          started -= 1;
          result.push(node);
        } else if (_comment === "HEAD_".concat(nodeId, "_START")) {
          started += 1;
          result.push(node);
        }
      } else if (started > 0) {
        result.push(node);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return result;
}
var HtmlTag = /*#__PURE__*/function () {
  function HtmlTag() {
    var is_svg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    _classCallCheck(this, HtmlTag);
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  _createClass(HtmlTag, [{
    key: "c",
    value: function c(html) {
      this.h(html);
    }
  }, {
    key: "m",
    value: function m(html, target) {
      var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (!this.e) {
        if (this.is_svg) this.e = svg_element(target.nodeName);
        /** #7364  target for <template> may be provided as #document-fragment(11) */else this.e = element(target.nodeType === 11 ? 'TEMPLATE' : target.nodeName);
        this.t = target.tagName !== 'TEMPLATE' ? target : target.content;
        this.c(html);
      }
      this.i(anchor);
    }
  }, {
    key: "h",
    value: function h(html) {
      this.e.innerHTML = html;
      this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);
    }
  }, {
    key: "i",
    value: function i(anchor) {
      for (var i = 0; i < this.n.length; i += 1) {
        insert(this.t, this.n[i], anchor);
      }
    }
  }, {
    key: "p",
    value: function p(html) {
      this.d();
      this.h(html);
      this.i(this.a);
    }
  }, {
    key: "d",
    value: function d() {
      this.n.forEach(detach);
    }
  }]);
  return HtmlTag;
}();
var HtmlTagHydration = /*#__PURE__*/function (_HtmlTag) {
  _inherits(HtmlTagHydration, _HtmlTag);
  var _super = _createSuper(HtmlTagHydration);
  function HtmlTagHydration(claimed_nodes) {
    var _this3;
    var is_svg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, HtmlTagHydration);
    _this3 = _super.call(this, is_svg);
    _this3.e = _this3.n = null;
    _this3.l = claimed_nodes;
    return _this3;
  }
  _createClass(HtmlTagHydration, [{
    key: "c",
    value: function c(html) {
      if (this.l) {
        this.n = this.l;
      } else {
        _get(_getPrototypeOf(HtmlTagHydration.prototype), "c", this).call(this, html);
      }
    }
  }, {
    key: "i",
    value: function i(anchor) {
      for (var i = 0; i < this.n.length; i += 1) {
        insert_hydration(this.t, this.n[i], anchor);
      }
    }
  }]);
  return HtmlTagHydration;
}(HtmlTag);
function attribute_to_object(attributes) {
  var result = {};
  var _iterator4 = _createForOfIteratorHelper(attributes),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var attribute = _step4.value;
      result[attribute.name] = attribute.value;
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return result;
}
function get_custom_elements_slots(element) {
  var result = {};
  element.childNodes.forEach(function (node) {
    result[node.slot || 'default'] = true;
  });
  return result;
}
function construct_svelte_component(component, props) {
  return new component(props);
}

// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
var managed_styles = new Map();
var active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
  var hash = 5381;
  var i = str.length;
  while (i--) hash = (hash << 5) - hash ^ str.charCodeAt(i);
  return hash >>> 0;
}
function create_style_information(doc, node) {
  var info = {
    stylesheet: append_empty_stylesheet(node),
    rules: {}
  };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn) {
  var uid = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  var step = 16.666 / duration;
  var keyframes = '{\n';
  for (var p = 0; p <= 1; p += step) {
    var t = a + (b - a) * ease(p);
    keyframes += p * 100 + "%{".concat(fn(t, 1 - t), "}\n");
  }
  var rule = keyframes + "100% {".concat(fn(b, 1 - b), "}\n}");
  var name = "__svelte_".concat(hash(rule), "_").concat(uid);
  var doc = get_root_for_style(node);
  var _ref2 = managed_styles.get(doc) || create_style_information(doc, node),
    stylesheet = _ref2.stylesheet,
    rules = _ref2.rules;
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule("@keyframes ".concat(name, " ").concat(rule), stylesheet.cssRules.length);
  }
  var animation = node.style.animation || '';
  node.style.animation = "".concat(animation ? "".concat(animation, ", ") : '').concat(name, " ").concat(duration, "ms linear ").concat(delay, "ms 1 both");
  active += 1;
  return name;
}
function delete_rule(node, name) {
  var previous = (node.style.animation || '').split(', ');
  var next = previous.filter(name ? function (anim) {
    return anim.indexOf(name) < 0;
  } // remove specific animation
  : function (anim) {
    return anim.indexOf('__svelte') === -1;
  } // remove all Svelte animations
  );

  var deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(', ');
    active -= deleted;
    if (!active) clear_rules();
  }
}
function clear_rules() {
  raf(function () {
    if (active) return;
    managed_styles.forEach(function (info) {
      var ownerNode = info.stylesheet.ownerNode;
      // there is no ownerNode if it runs on jsdom.
      if (ownerNode) detach(ownerNode);
    });
    managed_styles.clear();
  });
}
function create_animation(node, from, fn, params) {
  if (!from) return noop;
  var to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;
  var _fn = fn(node, {
      from: from,
      to: to
    }, params),
    _fn$delay = _fn.delay,
    delay = _fn$delay === void 0 ? 0 : _fn$delay,
    _fn$duration = _fn.duration,
    duration = _fn$duration === void 0 ? 300 : _fn$duration,
    _fn$easing = _fn.easing,
    easing = _fn$easing === void 0 ? identity : _fn$easing,
    _fn$start = _fn.start,
    start_time = _fn$start === void 0 ? now() + delay : _fn$start,
    _fn$end = _fn.end,
    end = _fn$end === void 0 ? start_time + duration : _fn$end,
    _fn$tick = _fn.tick,
    tick = _fn$tick === void 0 ? noop : _fn$tick,
    css = _fn.css;
  var running = true;
  var started = false;
  var name;
  function start() {
    if (css) {
      name = create_rule(node, 0, 1, duration, delay, easing, css);
    }
    if (!delay) {
      started = true;
    }
  }
  function stop() {
    if (css) delete_rule(node, name);
    running = false;
  }
  loop(function (now) {
    if (!started && now >= start_time) {
      started = true;
    }
    if (started && now >= end) {
      tick(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      var p = now - start_time;
      var t = 0 + 1 * easing(p / duration);
      tick(t, 1 - t);
    }
    return true;
  });
  start();
  tick(0, 1);
  return stop;
}
function fix_position(node) {
  var style = getComputedStyle(node);
  if (style.position !== 'absolute' && style.position !== 'fixed') {
    var width = style.width,
      height = style.height;
    var a = node.getBoundingClientRect();
    node.style.position = 'absolute';
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a);
  }
}
function add_transform(node, a) {
  var b = node.getBoundingClientRect();
  if (a.left !== b.left || a.top !== b.top) {
    var style = getComputedStyle(node);
    var transform = style.transform === 'none' ? '' : style.transform;
    node.style.transform = "".concat(transform, " translate(").concat(a.left - b.left, "px, ").concat(a.top - b.top, "px)");
  }
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error('Function called outside component initialization');
  return current_component;
}
/**
 * Schedules a callback to run immediately before the component is updated after any state change.
 *
 * The first time the callback runs will be before the initial `onMount`
 *
 * https://svelte.dev/docs#run-time-svelte-beforeupdate
 */
function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}
/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs#run-time-svelte-onmount
 */
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
/**
 * Schedules a callback to run immediately after the component has been updated.
 *
 * The first time the callback runs will be after the initial `onMount`
 */
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs#run-time-svelte-ondestroy
 */
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
 */
function createEventDispatcher() {
  var component = get_current_component();
  return function (type, detail) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref3$cancelable = _ref3.cancelable,
      cancelable = _ref3$cancelable === void 0 ? false : _ref3$cancelable;
    var callbacks = component.$$.callbacks[type];
    if (callbacks) {
      // TODO are there situations where events could be dispatched
      // in a server (non-DOM) environment?
      var event = custom_event(type, detail, {
        cancelable: cancelable
      });
      callbacks.slice().forEach(function (fn) {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
/**
 * Associates an arbitrary `context` object with the current component and the specified `key`
 * and returns that object. The context is then available to children of the component
 * (including slotted content) with `getContext`.
 *
 * Like lifecycle functions, this must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-setcontext
 */
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
/**
 * Retrieves the context that belongs to the closest parent component with the specified `key`.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-getcontext
 */
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
/**
 * Retrieves the whole context map that belongs to the closest parent component.
 * Must be called during component initialisation. Useful, for example, if you
 * programmatically create a component and want to pass the existing context to it.
 *
 * https://svelte.dev/docs#run-time-svelte-getallcontexts
 */
function getAllContexts() {
  return get_current_component().$$.context;
}
/**
 * Checks whether a given `key` has been set in the context of a parent component.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-hascontext
 */
function hasContext(key) {
  return get_current_component().$$.context.has(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
  var _this4 = this;
  var callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    // @ts-ignore
    callbacks.slice().forEach(function (fn) {
      return fn.call(_this4, event);
    });
  }
}
var dirty_components = [];
var intros = {
  enabled: false
};
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
var seen_callbacks = new Set();
var flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
  // Do not reenter flush while dirty components are updated, as this can
  // result in an infinite loop. Instead, let the inner flush handle it.
  // Reentrancy is ok afterwards for bindings etc.
  if (flushidx !== 0) {
    return;
  }
  var saved_component = current_component;
  do {
    // first, call beforeUpdate functions
    // and update components
    try {
      while (flushidx < dirty_components.length) {
        var component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      // reset dirty state to not end up in a deadlocked state and then rethrow
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    // then, once components are updated, call
    // afterUpdate functions. This may cause
    // subsequent updates...
    for (var i = 0; i < render_callbacks.length; i += 1) {
      var callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        // ...so guard against infinite loops
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    var dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
/**
 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
 */
function flush_render_callbacks(fns) {
  var filtered = [];
  var targets = [];
  render_callbacks.forEach(function (c) {
    return fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c);
  });
  targets.forEach(function (c) {
    return c();
  });
  render_callbacks = filtered;
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(function () {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event("".concat(direction ? 'intro' : 'outro').concat(kind)));
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros // parent group
  };
}

function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing["delete"](block);
    block.i(local);
  }
}
function transition_out(block, local, detach, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(function () {
      outroing["delete"](block);
      if (callback) {
        if (detach) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = {
  duration: 0
};
function create_in_transition(node, fn, params) {
  var options = {
    direction: 'in'
  };
  var config = fn(node, params, options);
  var running = false;
  var animation_name;
  var task;
  var uid = 0;
  function cleanup() {
    if (animation_name) delete_rule(node, animation_name);
  }
  function go() {
    var _ref4 = config || null_transition,
      _ref4$delay = _ref4.delay,
      delay = _ref4$delay === void 0 ? 0 : _ref4$delay,
      _ref4$duration = _ref4.duration,
      duration = _ref4$duration === void 0 ? 300 : _ref4$duration,
      _ref4$easing = _ref4.easing,
      easing = _ref4$easing === void 0 ? identity : _ref4$easing,
      _ref4$tick = _ref4.tick,
      tick = _ref4$tick === void 0 ? noop : _ref4$tick,
      css = _ref4.css;
    if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick(0, 1);
    var start_time = now() + delay;
    var end_time = start_time + duration;
    if (task) task.abort();
    running = true;
    add_render_callback(function () {
      return dispatch(node, true, 'start');
    });
    task = loop(function (now) {
      if (running) {
        if (now >= end_time) {
          tick(1, 0);
          dispatch(node, true, 'end');
          cleanup();
          return running = false;
        }
        if (now >= start_time) {
          var t = easing((now - start_time) / duration);
          tick(t, 1 - t);
        }
      }
      return running;
    });
  }
  var started = false;
  return {
    start: function start() {
      if (started) return;
      started = true;
      delete_rule(node);
      if (is_function(config)) {
        config = config(options);
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate: function invalidate() {
      started = false;
    },
    end: function end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn, params) {
  var options = {
    direction: 'out'
  };
  var config = fn(node, params, options);
  var running = true;
  var animation_name;
  var group = outros;
  group.r += 1;
  function go() {
    var _ref5 = config || null_transition,
      _ref5$delay = _ref5.delay,
      delay = _ref5$delay === void 0 ? 0 : _ref5$delay,
      _ref5$duration = _ref5.duration,
      duration = _ref5$duration === void 0 ? 300 : _ref5$duration,
      _ref5$easing = _ref5.easing,
      easing = _ref5$easing === void 0 ? identity : _ref5$easing,
      _ref5$tick = _ref5.tick,
      tick = _ref5$tick === void 0 ? noop : _ref5$tick,
      css = _ref5.css;
    if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    var start_time = now() + delay;
    var end_time = start_time + duration;
    add_render_callback(function () {
      return dispatch(node, false, 'start');
    });
    loop(function (now) {
      if (running) {
        if (now >= end_time) {
          tick(0, 1);
          dispatch(node, false, 'end');
          if (! --group.r) {
            // this will result in `end()` being called,
            // so we don't need to clean up here
            run_all(group.c);
          }
          return false;
        }
        if (now >= start_time) {
          var t = easing((now - start_time) / duration);
          tick(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config)) {
    wait().then(function () {
      // @ts-ignore
      config = config(options);
      go();
    });
  } else {
    go();
  }
  return {
    end: function end(reset) {
      if (reset && config.tick) {
        config.tick(1, 0);
      }
      if (running) {
        if (animation_name) delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn, params, intro) {
  var options = {
    direction: 'both'
  };
  var config = fn(node, params, options);
  var t = intro ? 0 : 1;
  var running_program = null;
  var pending_program = null;
  var animation_name = null;
  function clear_animation() {
    if (animation_name) delete_rule(node, animation_name);
  }
  function init(program, duration) {
    var d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d: d,
      duration: duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    var _ref6 = config || null_transition,
      _ref6$delay = _ref6.delay,
      delay = _ref6$delay === void 0 ? 0 : _ref6$delay,
      _ref6$duration = _ref6.duration,
      duration = _ref6$duration === void 0 ? 300 : _ref6$duration,
      _ref6$easing = _ref6.easing,
      easing = _ref6$easing === void 0 ? identity : _ref6$easing,
      _ref6$tick = _ref6.tick,
      tick = _ref6$tick === void 0 ? noop : _ref6$tick,
      css = _ref6.css;
    var program = {
      start: now() + delay,
      b: b
    };
    if (!b) {
      // @ts-ignore todo: improve typings
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      // if this is an intro, and there's a delay, we need to do
      // an initial tick and/or apply CSS animation immediately
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b) tick(0, 1);
      running_program = init(program, duration);
      add_render_callback(function () {
        return dispatch(node, b, 'start');
      });
      loop(function (now) {
        if (pending_program && now > pending_program.start) {
          running_program = init(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, 'start');
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now >= running_program.end) {
            tick(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, 'end');
            if (!pending_program) {
              // we're done
              if (running_program.b) {
                // intro — we can tidy up immediately
                clear_animation();
              } else {
                // outro — needs to be coordinated
                if (! --running_program.group.r) run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now >= running_program.start) {
            var p = now - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run: function run(b) {
      if (is_function(config)) {
        wait().then(function () {
          // @ts-ignore
          config = config(options);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end: function end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function handle_promise(promise, info) {
  var token = info.token = {};
  function update(type, index, key, value) {
    if (info.token !== token) return;
    info.resolved = value;
    var child_ctx = info.ctx;
    if (key !== undefined) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    var block = type && (info.current = type)(child_ctx);
    var needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach(function (block, i) {
          if (i !== index && block) {
            group_outros();
            transition_out(block, 1, 1, function () {
              if (info.blocks[i] === block) {
                info.blocks[i] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks) info.blocks[index] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise)) {
    var _current_component = get_current_component();
    promise.then(function (value) {
      set_current_component(_current_component);
      update(info.then, 1, info.value, value);
      set_current_component(null);
    }, function (error) {
      set_current_component(_current_component);
      update(info["catch"], 2, info.error, error);
      set_current_component(null);
      if (!info.hasCatch) {
        throw error;
      }
    });
    // if we previously had a then/catch block, destroy it
    if (info.current !== info.pending) {
      update(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update(info.then, 1, info.value, promise);
      return true;
    }
    info.resolved = promise;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  var child_ctx = ctx.slice();
  var resolved = info.resolved;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info["catch"]) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup["delete"](block.key);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, function () {
    lookup["delete"](block.key);
  });
}
function fix_and_destroy_block(block, lookup) {
  block.f();
  destroy_block(block, lookup);
}
function fix_and_outro_and_destroy_block(block, lookup) {
  block.f();
  outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
  var o = old_blocks.length;
  var n = list.length;
  var i = o;
  var old_indexes = {};
  while (i--) old_indexes[old_blocks[i].key] = i;
  var new_blocks = [];
  var new_lookup = new Map();
  var deltas = new Map();
  var updates = [];
  i = n;
  var _loop = function _loop() {
    var child_ctx = get_context(ctx, list, i);
    var key = get_key(child_ctx);
    var block = lookup.get(key);
    if (!block) {
      block = create_each_block(key, child_ctx);
      block.c();
    } else if (dynamic) {
      // defer updates until all the DOM shuffling is done
      updates.push(function () {
        return block.p(child_ctx, dirty);
      });
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
  };
  while (i--) {
    _loop();
  }
  var will_move = new Set();
  var did_move = new Set();
  function insert(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    var new_block = new_blocks[n - 1];
    var old_block = old_blocks[o - 1];
    var new_key = new_block.key;
    var old_key = old_block.key;
    if (new_block === old_block) {
      // do nothing
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      // remove old block
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    var _old_block = old_blocks[o];
    if (!new_lookup.has(_old_block.key)) destroy(_old_block, lookup);
  }
  while (n) insert(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
function validate_each_keys(ctx, list, get_context, get_key) {
  var keys = new Set();
  for (var i = 0; i < list.length; i++) {
    var key = get_key(get_context(ctx, list, i));
    if (keys.has(key)) {
      throw new Error('Cannot have duplicate keys in a keyed each');
    }
    keys.add(key);
  }
}
function get_spread_update(levels, updates) {
  var update = {};
  var to_null_out = {};
  var accounted_for = {
    $$scope: 1
  };
  var i = levels.length;
  while (i--) {
    var o = levels[i];
    var n = updates[i];
    if (n) {
      for (var key in o) {
        if (!(key in n)) to_null_out[key] = 1;
      }
      for (var _key5 in n) {
        if (!accounted_for[_key5]) {
          update[_key5] = n[_key5];
          accounted_for[_key5] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (var _key6 in o) {
        accounted_for[_key6] = 1;
      }
    }
  }
  for (var _key7 in to_null_out) {
    if (!(_key7 in update)) update[_key7] = undefined;
  }
  return update;
}
function get_spread_object(spread_props) {
  return _typeof(spread_props) === 'object' && spread_props !== null ? spread_props : {};
}
var _boolean_attributes = ['allowfullscreen', 'allowpaymentrequest', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default', 'defer', 'disabled', 'formnovalidate', 'hidden', 'inert', 'ismap', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'selected'];
/**
 * List of HTML boolean attributes (e.g. `<input disabled>`).
 * Source: https://html.spec.whatwg.org/multipage/indices.html
 */
var boolean_attributes = new Set([].concat(_boolean_attributes));

/** regex of all html void element names */
var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function is_void(name) {
  return void_element_names.test(name) || name.toLowerCase() === '!doctype';
}
var invalid_attribute_name_character = /(?:[\t-\r "'\/=>\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFDD0-\uFDEF\uFEFF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF])/;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter
function spread(args, attrs_to_add) {
  var attributes = Object.assign.apply(Object, [{}].concat(_toConsumableArray(args)));
  if (attrs_to_add) {
    var classes_to_add = attrs_to_add.classes;
    var styles_to_add = attrs_to_add.styles;
    if (classes_to_add) {
      if (attributes["class"] == null) {
        attributes["class"] = classes_to_add;
      } else {
        attributes["class"] += ' ' + classes_to_add;
      }
    }
    if (styles_to_add) {
      if (attributes.style == null) {
        attributes.style = style_object_to_string(styles_to_add);
      } else {
        attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));
      }
    }
  }
  var str = '';
  Object.keys(attributes).forEach(function (name) {
    if (invalid_attribute_name_character.test(name)) return;
    var value = attributes[name];
    if (value === true) str += ' ' + name;else if (boolean_attributes.has(name.toLowerCase())) {
      if (value) str += ' ' + name;
    } else if (value != null) {
      str += " ".concat(name, "=\"").concat(value, "\"");
    }
  });
  return str;
}
function merge_ssr_styles(style_attribute, style_directive) {
  var style_object = {};
  var _iterator5 = _createForOfIteratorHelper(style_attribute.split(';')),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var individual_style = _step5.value;
      var colon_index = individual_style.indexOf(':');
      var _name = individual_style.slice(0, colon_index).trim();
      var _value = individual_style.slice(colon_index + 1).trim();
      if (!_name) continue;
      style_object[_name] = _value;
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  for (var name in style_directive) {
    var value = style_directive[name];
    if (value) {
      style_object[name] = value;
    } else {
      delete style_object[name];
    }
  }
  return style_object;
}
var ATTR_REGEX = /[&"]/g;
var CONTENT_REGEX = /[&<]/g;
/**
 * Note: this method is performance sensitive and has been optimized
 * https://github.com/sveltejs/svelte/pull/5701
 */
function escape(value) {
  var is_attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var str = String(value);
  var pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  var escaped = '';
  var last = 0;
  while (pattern.test(str)) {
    var i = pattern.lastIndex - 1;
    var ch = str[i];
    escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '"' ? '&quot;' : '&lt;');
    last = i + 1;
  }
  return escaped + str.substring(last);
}
function escape_attribute_value(value) {
  // keep booleans, null, and undefined for the sake of `spread`
  var should_escape = typeof value === 'string' || value && _typeof(value) === 'object';
  return should_escape ? escape(value, true) : value;
}
function escape_object(obj) {
  var result = {};
  for (var key in obj) {
    result[key] = escape_attribute_value(obj[key]);
  }
  return result;
}
function each(items, fn) {
  var str = '';
  for (var i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: function $$render() {
    return '';
  }
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === 'svelte:component') name += ' this={...}';
    throw new Error("<".concat(name, "> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <").concat(name, ">."));
  }
  return component;
}
function debug(file, line, column, values) {
  console.log("{@debug} ".concat(file ? file + ' ' : '', "(").concat(line, ":").concat(column, ")")); // eslint-disable-line no-console
  console.log(values); // eslint-disable-line no-console
  return '';
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    var parent_component = current_component;
    var $$ = {
      on_destroy: on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      // these will be immediately discarded
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({
      $$: $$
    });
    var html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: function render() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref7$$$slots = _ref7.$$slots,
        $$slots = _ref7$$$slots === void 0 ? {} : _ref7$$$slots,
        _ref7$context = _ref7.context,
        context = _ref7$context === void 0 ? new Map() : _ref7$context;
      on_destroy = [];
      var result = {
        title: '',
        head: '',
        css: new Set()
      };
      var html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html: html,
        css: {
          code: Array.from(result.css).map(function (css) {
            return css.code;
          }).join('\n'),
          map: null // TODO
        },

        head: result.title + result.head
      };
    },
    $$render: $$render
  };
}
function add_attribute(name, value, _boolean) {
  if (value == null || _boolean && !value) return '';
  var assignment = _boolean && value === true ? '' : "=\"".concat(escape(value, true), "\"");
  return " ".concat(name).concat(assignment);
}
function add_classes(classes) {
  return classes ? " class=\"".concat(classes, "\"") : '';
}
function style_object_to_string(style_object) {
  return Object.keys(style_object).filter(function (key) {
    return style_object[key];
  }).map(function (key) {
    return "".concat(key, ": ").concat(escape_attribute_value(style_object[key]), ";");
  }).join(' ');
}
function add_styles(style_object) {
  var styles = style_object_to_string(style_object);
  return styles ? " style=\"".concat(styles, "\"") : '';
}
function bind(component, name, callback) {
  var index = component.$$.props[name];
  if (index !== undefined) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function claim_component(block, parent_nodes) {
  block && block.l(parent_nodes);
}
function mount_component(component, target, anchor, customElement) {
  var _component$$$ = component.$$,
    fragment = _component$$$.fragment,
    after_update = _component$$$.after_update;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    // onMount happens before the initial afterUpdate
    add_render_callback(function () {
      var new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      // if the component was destroyed immediately
      // it will update the `$$.on_destroy` reference to `null`.
      // the destructured on_destroy may still reference to the old array
      if (component.$$.on_destroy) {
        var _component$$$$on_dest;
        (_component$$$$on_dest = component.$$.on_destroy).push.apply(_component$$$$on_dest, _toConsumableArray(new_on_destroy));
      } else {
        // Edge case - component was destroyed immediately,
        // most likely as a result of a binding initialising
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  var $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    // TODO null out other refs, including component.$$ (but need to
    // preserve final state?)
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles) {
  var dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
  var parent_component = current_component;
  set_current_component(component);
  var $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: props,
    update: noop,
    not_equal: not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty: dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  var ready = false;
  $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
    var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  // `false` as a special case of no DOM component
  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      var nodes = children(options.target);
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === 'function') {
  SvelteElement = /*#__PURE__*/function (_HTMLElement) {
    _inherits(SvelteElement, _HTMLElement);
    var _super2 = _createSuper(SvelteElement);
    function SvelteElement() {
      var _this5;
      _classCallCheck(this, SvelteElement);
      _this5 = _super2.call(this);
      _this5.attachShadow({
        mode: 'open'
      });
      return _this5;
    }
    _createClass(SvelteElement, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        var on_mount = this.$$.on_mount;
        this.$$.on_disconnect = on_mount.map(run).filter(is_function);
        // @ts-ignore todo: improve typings
        for (var key in this.$$.slotted) {
          // @ts-ignore todo: improve typings
          this.appendChild(this.$$.slotted[key]);
        }
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attr, _oldValue, newValue) {
        this[attr] = newValue;
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        run_all(this.$$.on_disconnect);
      }
    }, {
      key: "$destroy",
      value: function $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }
    }, {
      key: "$on",
      value: function $on(type, callback) {
        // TODO should this delegate to addEventListener?
        if (!is_function(callback)) {
          return noop;
        }
        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return function () {
          var index = callbacks.indexOf(callback);
          if (index !== -1) callbacks.splice(index, 1);
        };
      }
    }, {
      key: "$set",
      value: function $set($$props) {
        if (this.$$set && !is_empty($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }
    }]);
    return SvelteElement;
  }( /*#__PURE__*/_wrapNativeSuper(HTMLElement));
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
var SvelteComponent = /*#__PURE__*/function () {
  function SvelteComponent() {
    _classCallCheck(this, SvelteComponent);
  }
  _createClass(SvelteComponent, [{
    key: "$destroy",
    value: function $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
  }, {
    key: "$on",
    value: function $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return function () {
        var index = callbacks.indexOf(callback);
        if (index !== -1) callbacks.splice(index, 1);
      };
    }
  }, {
    key: "$set",
    value: function $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  }]);
  return SvelteComponent;
}();
function dispatch_dev(type, detail) {
  document.dispatchEvent(custom_event(type, Object.assign({
    version: '3.59.1'
  }, detail), {
    bubbles: true
  }));
}
function append_dev(target, node) {
  dispatch_dev('SvelteDOMInsert', {
    target: target,
    node: node
  });
  append(target, node);
}
function append_hydration_dev(target, node) {
  dispatch_dev('SvelteDOMInsert', {
    target: target,
    node: node
  });
  append_hydration(target, node);
}
function insert_dev(target, node, anchor) {
  dispatch_dev('SvelteDOMInsert', {
    target: target,
    node: node,
    anchor: anchor
  });
  insert(target, node, anchor);
}
function insert_hydration_dev(target, node, anchor) {
  dispatch_dev('SvelteDOMInsert', {
    target: target,
    node: node,
    anchor: anchor
  });
  insert_hydration(target, node, anchor);
}
function detach_dev(node) {
  dispatch_dev('SvelteDOMRemove', {
    node: node
  });
  detach(node);
}
function detach_between_dev(before, after) {
  while (before.nextSibling && before.nextSibling !== after) {
    detach_dev(before.nextSibling);
  }
}
function detach_before_dev(after) {
  while (after.previousSibling) {
    detach_dev(after.previousSibling);
  }
}
function detach_after_dev(before) {
  while (before.nextSibling) {
    detach_dev(before.nextSibling);
  }
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
  var modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
  if (has_prevent_default) modifiers.push('preventDefault');
  if (has_stop_propagation) modifiers.push('stopPropagation');
  if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
  dispatch_dev('SvelteDOMAddEventListener', {
    node: node,
    event: event,
    handler: handler,
    modifiers: modifiers
  });
  var dispose = listen(node, event, handler, options);
  return function () {
    dispatch_dev('SvelteDOMRemoveEventListener', {
      node: node,
      event: event,
      handler: handler,
      modifiers: modifiers
    });
    dispose();
  };
}
function attr_dev(node, attribute, value) {
  attr(node, attribute, value);
  if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
    node: node,
    attribute: attribute
  });else dispatch_dev('SvelteDOMSetAttribute', {
    node: node,
    attribute: attribute,
    value: value
  });
}
function prop_dev(node, property, value) {
  node[property] = value;
  dispatch_dev('SvelteDOMSetProperty', {
    node: node,
    property: property,
    value: value
  });
}
function dataset_dev(node, property, value) {
  node.dataset[property] = value;
  dispatch_dev('SvelteDOMSetDataset', {
    node: node,
    property: property,
    value: value
  });
}
function set_data_dev(text, data) {
  data = '' + data;
  if (text.data === data) return;
  dispatch_dev('SvelteDOMSetData', {
    node: text,
    data: data
  });
  text.data = data;
}
function set_data_contenteditable_dev(text, data) {
  data = '' + data;
  if (text.wholeText === data) return;
  dispatch_dev('SvelteDOMSetData', {
    node: text,
    data: data
  });
  text.data = data;
}
function set_data_maybe_contenteditable_dev(text, data, attr_value) {
  if (~contenteditable_truthy_values.indexOf(attr_value)) {
    set_data_contenteditable_dev(text, data);
  } else {
    set_data_dev(text, data);
  }
}
function validate_each_argument(arg) {
  if (typeof arg !== 'string' && !(arg && _typeof(arg) === 'object' && 'length' in arg)) {
    var msg = '{#each} only iterates over array-like objects.';
    if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
      msg += ' You can use a spread to convert this iterable into an array.';
    }
    throw new Error(msg);
  }
}
function validate_slots(name, slot, keys) {
  for (var _i4 = 0, _Object$keys = Object.keys(slot); _i4 < _Object$keys.length; _i4++) {
    var slot_key = _Object$keys[_i4];
    if (!~keys.indexOf(slot_key)) {
      console.warn("<".concat(name, "> received an unexpected slot \"").concat(slot_key, "\"."));
    }
  }
}
function validate_dynamic_element(tag) {
  var is_string = typeof tag === 'string';
  if (tag && !is_string) {
    throw new Error('<svelte:element> expects "this" attribute to be a string.');
  }
}
function validate_void_dynamic_element(tag) {
  if (tag && is_void(tag)) {
    console.warn("<svelte:element this=\"".concat(tag, "\"> is self-closing and cannot have content."));
  }
}
function construct_svelte_component_dev(component, props) {
  var error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
  try {
    var instance = new component(props);
    if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
      throw new Error(error_message);
    }
    return instance;
  } catch (err) {
    var message = err.message;
    if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
      throw new Error(error_message);
    } else {
      throw err;
    }
  }
}
/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */
var SvelteComponentDev = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(SvelteComponentDev, _SvelteComponent);
  var _super3 = _createSuper(SvelteComponentDev);
  function SvelteComponentDev(options) {
    _classCallCheck(this, SvelteComponentDev);
    if (!options || !options.target && !options.$$inline) {
      throw new Error("'target' is a required option");
    }
    return _super3.call(this);
  }
  _createClass(SvelteComponentDev, [{
    key: "$destroy",
    value: function $destroy() {
      _get(_getPrototypeOf(SvelteComponentDev.prototype), "$destroy", this).call(this);
      this.$destroy = function () {
        console.warn('Component was already destroyed'); // eslint-disable-line no-console
      };
    }
  }, {
    key: "$capture_state",
    value: function $capture_state() {}
  }, {
    key: "$inject_state",
    value: function $inject_state() {}
  }]);
  return SvelteComponentDev;
}(SvelteComponent);
/**
 * Base class to create strongly typed Svelte components.
 * This only exists for typing purposes and should be used in `.d.ts` files.
 *
 * ### Example:
 *
 * You have component library on npm called `component-library`, from which
 * you export a component called `MyComponent`. For Svelte+TypeScript users,
 * you want to provide typings. Therefore you create a `index.d.ts`:
 * ```ts
 * import { SvelteComponentTyped } from "svelte";
 * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
 * ```
 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
 * to provide intellisense and to use the component like this in a Svelte file
 * with TypeScript:
 * ```svelte
 * <script lang="ts">
 * 	import { MyComponent } from "component-library";
 * </script>
 * <MyComponent foo={'bar'} />
 * ```
 *
 * #### Why not make this part of `SvelteComponent(Dev)`?
 * Because
 * ```ts
 * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
 * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
 * ```
 * will throw a type error, so we need to separate the more strictly typed class.
 */
var SvelteComponentTyped = /*#__PURE__*/function (_SvelteComponentDev) {
  _inherits(SvelteComponentTyped, _SvelteComponentDev);
  var _super4 = _createSuper(SvelteComponentTyped);
  function SvelteComponentTyped(options) {
    _classCallCheck(this, SvelteComponentTyped);
    return _super4.call(this, options);
  }
  return _createClass(SvelteComponentTyped);
}(SvelteComponentDev);
function loop_guard(timeout) {
  var start = Date.now();
  return function () {
    if (Date.now() - start > timeout) {
      throw new Error('Infinite loop detected');
    }
  };
}


/***/ }),

/***/ "./node_modules/svelte/store/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/svelte/store/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   derived: () => (/* binding */ derived),
/* harmony export */   get: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.get_store_value),
/* harmony export */   readable: () => (/* binding */ readable),
/* harmony export */   readonly: () => (/* binding */ readonly),
/* harmony export */   writable: () => (/* binding */ writable)
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }


var subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier} [start]
 */
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=} start
 */
function writable(value) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
  var stop;
  var subscribers = new Set();
  function set(new_value) {
    if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal)(value, new_value)) {
      value = new_value;
      if (stop) {
        // store is ready
        var run_queue = !subscriber_queue.length;
        var _iterator = _createForOfIteratorHelper(subscribers),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var subscriber = _step.value;
            subscriber[1]();
            subscriber_queue.push(subscriber, value);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (run_queue) {
          for (var i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe(run) {
    var invalidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
    var subscriber = [run, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
    }
    run(value);
    return function () {
      subscribers["delete"](subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return {
    set: set,
    update: update,
    subscribe: subscribe
  };
}
function derived(stores, fn, initial_value) {
  var single = !Array.isArray(stores);
  var stores_array = single ? [stores] : stores;
  var auto = fn.length < 2;
  return readable(initial_value, function (set) {
    var started = false;
    var values = [];
    var pending = 0;
    var cleanup = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
    var sync = function sync() {
      if (pending) {
        return;
      }
      cleanup();
      var result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.is_function)(result) ? result : _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
      }
    };
    var unsubscribers = stores_array.map(function (store, i) {
      return (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.subscribe)(store, function (value) {
        values[i] = value;
        pending &= ~(1 << i);
        if (started) {
          sync();
        }
      }, function () {
        pending |= 1 << i;
      });
    });
    started = true;
    sync();
    return function stop() {
      (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.run_all)(unsubscribers);
      cleanup();
      // We need to set this to false because callbacks can still happen despite having unsubscribed:
      // Callbacks might already be placed in the queue which doesn't know it should no longer
      // invoke this derived store.
      started = false;
    };
  });
}
/**
 * Takes a store and returns a new one derived from the old one that is readable.
 *
 * @param store - store to make readonly
 */
function readonly(store) {
  return {
    subscribe: store.subscribe.bind(store)
  };
}


/***/ }),

/***/ "./node_modules/svelte-floating-ui/index.js":
/*!**************************************************!*\
  !*** ./node_modules/svelte-floating-ui/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* binding */ arrow),
/* harmony export */   createFloatingActions: () => (/* binding */ createFloatingActions)
/* harmony export */ });
/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/core */ "./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs");
/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
//@ts-ignore




function createFloatingActions(initOptions) {
    let referenceElement;
    let floatingElement;
    const defaultOptions = {
        autoUpdate: true
    };
    let options = initOptions;
    const getOptions = (mixin) => {
        return { ...defaultOptions, ...(initOptions || {}), ...(mixin || {}) };
    };
    const updatePosition = (updateOptions) => {
        if (referenceElement && floatingElement) {
            options = getOptions(updateOptions);
            (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition)(referenceElement, floatingElement, options)
                .then(v => {
                Object.assign(floatingElement.style, {
                    position: v.strategy,
                    left: `${v.x}px`,
                    top: `${v.y}px`,
                });
                options?.onComputed && options.onComputed(v);
            });
        }
    };
    const referenceAction = node => {
        if ('subscribe' in node) {
            setupVirtualElementObserver(node);
            return {};
        }
        else {
            referenceElement = node;
            updatePosition();
        }
    };
    const contentAction = (node, contentOptions) => {
        let autoUpdateDestroy;
        floatingElement = node;
        options = getOptions(contentOptions);
        setTimeout(() => updatePosition(contentOptions), 0); //tick doesn't work
        updatePosition(contentOptions);
        const destroyAutoUpdate = () => {
            if (autoUpdateDestroy) {
                autoUpdateDestroy();
                autoUpdateDestroy = undefined;
            }
        };
        const initAutoUpdate = ({ autoUpdate } = options || {}) => {
            destroyAutoUpdate();
            if (autoUpdate !== false) {
                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.autoUpdate)(referenceElement, floatingElement, () => updatePosition(options), (autoUpdate === true ? {} : autoUpdate));
            }
            return;
        };
        autoUpdateDestroy = initAutoUpdate();
        return {
            update(contentOptions) {
                updatePosition(contentOptions);
                autoUpdateDestroy = initAutoUpdate(contentOptions);
            },
            destroy() {
                destroyAutoUpdate();
            }
        };
    };
    const setupVirtualElementObserver = (node) => {
        const unsubscribe = node.subscribe(($node) => {
            if (referenceElement === undefined) {
                referenceElement = $node;
                updatePosition();
            }
            else {
                // Preserve the reference to the virtual element.
                Object.assign(referenceElement, $node);
                updatePosition();
            }
        });
        (0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(unsubscribe);
    };
    return [
        referenceAction,
        contentAction,
        updatePosition
    ];
}
function arrow(options) {
    return {
        name: "arrow",
        options,
        fn(args) {
            const element = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.get)(options.element);
            if (element) {
                return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_3__.arrow)({
                    element,
                    padding: options.padding
                }).fn(args);
            }
            return {};
        }
    };
}


/***/ }),

/***/ "./node_modules/svelte-select/filter.js":
/*!**********************************************!*\
  !*** ./node_modules/svelte-select/filter.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filter)
/* harmony export */ });
function filter({
    loadOptions,
    filterText,
    items,
    multiple,
    value,
    itemId,
    groupBy,
    filterSelectedItems,
    itemFilter,
    convertStringItemsToObjects,
    filterGroupedItems,
    label,
}) {
    if (items && loadOptions) return items;
    if (!items) return [];

    if (items && items.length > 0 && typeof items[0] !== 'object') {
        items = convertStringItemsToObjects(items);
    }

    let filterResults = items.filter((item) => {
        let matchesFilter = itemFilter(item[label], filterText, item);
        if (matchesFilter && multiple && value?.length) {
            matchesFilter = !value.some((x) => {
                return filterSelectedItems ? x[itemId] === item[itemId] : false;
            });
        }

        return matchesFilter;
    });

    if (groupBy) {
        filterResults = filterGroupedItems(filterResults);
    }

    return filterResults;
}


/***/ }),

/***/ "./node_modules/svelte-select/get-items.js":
/*!*************************************************!*\
  !*** ./node_modules/svelte-select/get-items.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getItems)
/* harmony export */ });
async function getItems({ dispatch, loadOptions, convertStringItemsToObjects, filterText }) {
    let res = await loadOptions(filterText).catch((err) => {
        console.warn('svelte-select loadOptions error :>> ', err);
        dispatch('error', { type: 'loadOptions', details: err });
    });

    if (res && !res.cancelled) {        
        if (res) {
            if (res && res.length > 0 && typeof res[0] !== 'object') {
                res = convertStringItemsToObjects(res);
            }
            
            dispatch('loaded', { items: res });
        } else {
            res = [];
        }

        return {
            filteredItems: res,
            loading: false,
            focused: true,
            listOpen: true,
        };
    }
}


/***/ }),

/***/ "./node_modules/svelte-select/index.js":
/*!*********************************************!*\
  !*** ./node_modules/svelte-select/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _Select_svelte__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _Select_svelte__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Select.svelte */ "./node_modules/svelte-select/Select.svelte");



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/css/app.css")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;